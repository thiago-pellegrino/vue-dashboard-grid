import {
  __commonJS
} from "./chunk-Z47AEMLX.js";

// node_modules/vue-element-resize-detector/dist/vue-element-resize-detector.common.js
var require_vue_element_resize_detector_common = __commonJS({
  "node_modules/vue-element-resize-detector/dist/vue-element-resize-detector.common.js"(exports, module) {
    module.exports = function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      "18d2": function(module2, exports2, __webpack_require__) {
        "use strict";
        var browserDetector = __webpack_require__("18e9");
        module2.exports = function(options) {
          options = options || {};
          var reporter = options.reporter;
          var batchProcessor = options.batchProcessor;
          var getState = options.stateHandler.getState;
          if (!reporter) {
            throw new Error("Missing required dependency: reporter.");
          }
          function addListener(element, listener) {
            function listenerProxy() {
              listener(element);
            }
            if (browserDetector.isIE(8)) {
              getState(element).object = {
                proxy: listenerProxy
              };
              element.attachEvent("onresize", listenerProxy);
            } else {
              var object = getObject(element);
              if (!object) {
                throw new Error("Element is not detectable by this strategy.");
              }
              object.contentDocument.defaultView.addEventListener("resize", listenerProxy);
            }
          }
          function buildCssTextString(rules) {
            var seperator = options.important ? " !important; " : "; ";
            return (rules.join(seperator) + seperator).trim();
          }
          function makeDetectable(options2, element, callback) {
            if (!callback) {
              callback = element;
              element = options2;
              options2 = null;
            }
            options2 = options2 || {};
            var debug = options2.debug;
            function injectObject(element2, callback2) {
              var OBJECT_STYLE = buildCssTextString(["display: block", "position: absolute", "top: 0", "left: 0", "width: 100%", "height: 100%", "border: none", "padding: 0", "margin: 0", "opacity: 0", "z-index: -1000", "pointer-events: none"]);
              var positionCheckPerformed = false;
              var style = window.getComputedStyle(element2);
              var width = element2.offsetWidth;
              var height = element2.offsetHeight;
              getState(element2).startSize = {
                width,
                height
              };
              function mutateDom() {
                function alterPositionStyles() {
                  if (style.position === "static") {
                    element2.style.setProperty("position", "relative", options2.important ? "important" : "");
                    var removeRelativeStyles = function(reporter2, element3, style2, property) {
                      function getNumericalValue(value2) {
                        return value2.replace(/[^-\d\.]/g, "");
                      }
                      var value = style2[property];
                      if (value !== "auto" && getNumericalValue(value) !== "0") {
                        reporter2.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element3);
                        element3.style.setProperty(property, "0", options2.important ? "important" : "");
                      }
                    };
                    removeRelativeStyles(reporter, element2, style, "top");
                    removeRelativeStyles(reporter, element2, style, "right");
                    removeRelativeStyles(reporter, element2, style, "bottom");
                    removeRelativeStyles(reporter, element2, style, "left");
                  }
                }
                function onObjectLoad() {
                  if (!positionCheckPerformed) {
                    alterPositionStyles();
                  }
                  function getDocument(element3, callback3) {
                    if (!element3.contentDocument) {
                      var state = getState(element3);
                      if (state.checkForObjectDocumentTimeoutId) {
                        window.clearTimeout(state.checkForObjectDocumentTimeoutId);
                      }
                      state.checkForObjectDocumentTimeoutId = setTimeout(function checkForObjectDocument() {
                        state.checkForObjectDocumentTimeoutId = 0;
                        getDocument(element3, callback3);
                      }, 100);
                      return;
                    }
                    callback3(element3.contentDocument);
                  }
                  var objectElement = this;
                  getDocument(objectElement, function onObjectDocumentReady(objectDocument) {
                    callback2(element2);
                  });
                }
                if (style.position !== "") {
                  alterPositionStyles(style);
                  positionCheckPerformed = true;
                }
                var object = document.createElement("object");
                object.style.cssText = OBJECT_STYLE;
                object.tabIndex = -1;
                object.type = "text/html";
                object.setAttribute("aria-hidden", "true");
                object.onload = onObjectLoad;
                if (!browserDetector.isIE()) {
                  object.data = "about:blank";
                }
                if (!getState(element2)) {
                  return;
                }
                element2.appendChild(object);
                getState(element2).object = object;
                if (browserDetector.isIE()) {
                  object.data = "about:blank";
                }
              }
              if (batchProcessor) {
                batchProcessor.add(mutateDom);
              } else {
                mutateDom();
              }
            }
            if (browserDetector.isIE(8)) {
              callback(element);
            } else {
              injectObject(element, callback);
            }
          }
          function getObject(element) {
            return getState(element).object;
          }
          function uninstall(element) {
            if (!getState(element)) {
              return;
            }
            var object = getObject(element);
            if (!object) {
              return;
            }
            if (browserDetector.isIE(8)) {
              element.detachEvent("onresize", object.proxy);
            } else {
              element.removeChild(object);
            }
            if (getState(element).checkForObjectDocumentTimeoutId) {
              window.clearTimeout(getState(element).checkForObjectDocumentTimeoutId);
            }
            delete getState(element).object;
          }
          return {
            makeDetectable,
            addListener,
            uninstall
          };
        };
      },
      "18e9": function(module2, exports2, __webpack_require__) {
        "use strict";
        var detector = module2.exports = {};
        detector.isIE = function(version) {
          function isAnyIeVersion() {
            var agent = navigator.userAgent.toLowerCase();
            return agent.indexOf("msie") !== -1 || agent.indexOf("trident") !== -1 || agent.indexOf(" edge/") !== -1;
          }
          if (!isAnyIeVersion()) {
            return false;
          }
          if (!version) {
            return true;
          }
          var ieVersion = function() {
            var undef, v = 3, div = document.createElement("div"), all = div.getElementsByTagName("i");
            do {
              div.innerHTML = "<!--[if gt IE " + ++v + "]><i></i><![endif]-->";
            } while (all[0]);
            return v > 4 ? v : undef;
          }();
          return version === ieVersion;
        };
        detector.isLegacyOpera = function() {
          return !!window.opera;
        };
      },
      "2cef": function(module2, exports2, __webpack_require__) {
        "use strict";
        module2.exports = function() {
          var idCount = 1;
          function generate() {
            return idCount++;
          }
          return {
            generate
          };
        };
      },
      "49ad": function(module2, exports2, __webpack_require__) {
        "use strict";
        module2.exports = function(idHandler) {
          var eventListeners = {};
          function getListeners(element) {
            var id = idHandler.get(element);
            if (id === void 0) {
              return [];
            }
            return eventListeners[id] || [];
          }
          function addListener(element, listener) {
            var id = idHandler.get(element);
            if (!eventListeners[id]) {
              eventListeners[id] = [];
            }
            eventListeners[id].push(listener);
          }
          function removeListener(element, listener) {
            var listeners = getListeners(element);
            for (var i = 0, len = listeners.length; i < len; ++i) {
              if (listeners[i] === listener) {
                listeners.splice(i, 1);
                break;
              }
            }
          }
          function removeAllListeners(element) {
            var listeners = getListeners(element);
            if (!listeners) {
              return;
            }
            listeners.length = 0;
          }
          return {
            get: getListeners,
            add: addListener,
            removeListener,
            removeAllListeners
          };
        };
      },
      "5058": function(module2, exports2, __webpack_require__) {
        "use strict";
        module2.exports = function(options) {
          var idGenerator = options.idGenerator;
          var getState = options.stateHandler.getState;
          function getId(element) {
            var state = getState(element);
            if (state && state.id !== void 0) {
              return state.id;
            }
            return null;
          }
          function setId(element) {
            var state = getState(element);
            if (!state) {
              throw new Error("setId required the element to have a resize detection state.");
            }
            var id = idGenerator.generate();
            state.id = id;
            return id;
          }
          return {
            get: getId,
            set: setId
          };
        };
      },
      "50bf": function(module2, exports2, __webpack_require__) {
        "use strict";
        var utils = module2.exports = {};
        utils.getOption = getOption;
        function getOption(options, name, defaultValue) {
          var value = options[name];
          if ((value === void 0 || value === null) && defaultValue !== void 0) {
            return defaultValue;
          }
          return value;
        }
      },
      "5be5": function(module2, exports2, __webpack_require__) {
        "use strict";
        module2.exports = function(options) {
          var getState = options.stateHandler.getState;
          function isDetectable(element) {
            var state = getState(element);
            return state && !!state.isDetectable;
          }
          function markAsDetectable(element) {
            getState(element).isDetectable = true;
          }
          function isBusy(element) {
            return !!getState(element).busy;
          }
          function markBusy(element, busy) {
            getState(element).busy = !!busy;
          }
          return {
            isDetectable,
            markAsDetectable,
            isBusy,
            markBusy
          };
        };
      },
      "abb4": function(module2, exports2, __webpack_require__) {
        "use strict";
        module2.exports = function(quiet) {
          function noop() {
          }
          var reporter = {
            log: noop,
            warn: noop,
            error: noop
          };
          if (!quiet && window.console) {
            var attachFunction = function(reporter2, name) {
              reporter2[name] = function reporterProxy() {
                var f = console[name];
                if (f.apply) {
                  f.apply(console, arguments);
                } else {
                  for (var i = 0; i < arguments.length; i++) {
                    f(arguments[i]);
                  }
                }
              };
            };
            attachFunction(reporter, "log");
            attachFunction(reporter, "warn");
            attachFunction(reporter, "error");
          }
          return reporter;
        };
      },
      "b770": function(module2, exports2, __webpack_require__) {
        "use strict";
        var utils = module2.exports = {};
        utils.forEach = function(collection, callback) {
          for (var i = 0; i < collection.length; i++) {
            var result = callback(collection[i]);
            if (result) {
              return result;
            }
          }
        };
      },
      "c274": function(module2, exports2, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__("50bf");
        module2.exports = function batchProcessorMaker(options) {
          options = options || {};
          var reporter = options.reporter;
          var asyncProcess = utils.getOption(options, "async", true);
          var autoProcess = utils.getOption(options, "auto", true);
          if (autoProcess && !asyncProcess) {
            reporter && reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");
            asyncProcess = true;
          }
          var batch = Batch();
          var asyncFrameHandler;
          var isProcessing = false;
          function addFunction(level, fn) {
            if (!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {
              processBatchAsync();
            }
            batch.add(level, fn);
          }
          function processBatch() {
            isProcessing = true;
            while (batch.size()) {
              var processingBatch = batch;
              batch = Batch();
              processingBatch.process();
            }
            isProcessing = false;
          }
          function forceProcessBatch(localAsyncProcess) {
            if (isProcessing) {
              return;
            }
            if (localAsyncProcess === void 0) {
              localAsyncProcess = asyncProcess;
            }
            if (asyncFrameHandler) {
              cancelFrame(asyncFrameHandler);
              asyncFrameHandler = null;
            }
            if (localAsyncProcess) {
              processBatchAsync();
            } else {
              processBatch();
            }
          }
          function processBatchAsync() {
            asyncFrameHandler = requestFrame(processBatch);
          }
          function clearBatch() {
            batch = {};
            batchSize = 0;
            topLevel = 0;
            bottomLevel = 0;
          }
          function cancelFrame(listener) {
            var cancel = clearTimeout;
            return cancel(listener);
          }
          function requestFrame(callback) {
            var raf = function(fn) {
              return setTimeout(fn, 0);
            };
            return raf(callback);
          }
          return {
            add: addFunction,
            force: forceProcessBatch
          };
        };
        function Batch() {
          var batch = {};
          var size = 0;
          var topLevel2 = 0;
          var bottomLevel2 = 0;
          function add(level, fn) {
            if (!fn) {
              fn = level;
              level = 0;
            }
            if (level > topLevel2) {
              topLevel2 = level;
            } else if (level < bottomLevel2) {
              bottomLevel2 = level;
            }
            if (!batch[level]) {
              batch[level] = [];
            }
            batch[level].push(fn);
            size++;
          }
          function process() {
            for (var level = bottomLevel2; level <= topLevel2; level++) {
              var fns = batch[level];
              for (var i = 0; i < fns.length; i++) {
                var fn = fns[i];
                fn();
              }
            }
          }
          function getSize() {
            return size;
          }
          return {
            add,
            process,
            size: getSize
          };
        }
      },
      "c946": function(module2, exports2, __webpack_require__) {
        "use strict";
        var forEach = __webpack_require__("b770").forEach;
        module2.exports = function(options) {
          options = options || {};
          var reporter = options.reporter;
          var batchProcessor = options.batchProcessor;
          var getState = options.stateHandler.getState;
          var hasState = options.stateHandler.hasState;
          var idHandler = options.idHandler;
          if (!batchProcessor) {
            throw new Error("Missing required dependency: batchProcessor");
          }
          if (!reporter) {
            throw new Error("Missing required dependency: reporter.");
          }
          var scrollbarSizes = getScrollbarSizes();
          var styleId = "erd_scroll_detection_scrollbar_style";
          var detectionContainerClass = "erd_scroll_detection_container";
          function initDocument(targetDocument) {
            injectScrollStyle(targetDocument, styleId, detectionContainerClass);
          }
          initDocument(window.document);
          function buildCssTextString(rules) {
            var seperator = options.important ? " !important; " : "; ";
            return (rules.join(seperator) + seperator).trim();
          }
          function getScrollbarSizes() {
            var width = 500;
            var height = 500;
            var child = document.createElement("div");
            child.style.cssText = buildCssTextString(["position: absolute", "width: " + width * 2 + "px", "height: " + height * 2 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
            var container = document.createElement("div");
            container.style.cssText = buildCssTextString(["position: absolute", "width: " + width + "px", "height: " + height + "px", "overflow: scroll", "visibility: none", "top: " + -width * 3 + "px", "left: " + -height * 3 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
            container.appendChild(child);
            document.body.insertBefore(container, document.body.firstChild);
            var widthSize = width - container.clientWidth;
            var heightSize = height - container.clientHeight;
            document.body.removeChild(container);
            return {
              width: widthSize,
              height: heightSize
            };
          }
          function injectScrollStyle(targetDocument, styleId2, containerClass) {
            function injectStyle(style2, method) {
              method = method || function(element) {
                targetDocument.head.appendChild(element);
              };
              var styleElement = targetDocument.createElement("style");
              styleElement.innerHTML = style2;
              styleElement.id = styleId2;
              method(styleElement);
              return styleElement;
            }
            if (!targetDocument.getElementById(styleId2)) {
              var containerAnimationClass = containerClass + "_animation";
              var containerAnimationActiveClass = containerClass + "_animation_active";
              var style = "/* Created by the element-resize-detector library. */\n";
              style += "." + containerClass + " > div::-webkit-scrollbar { " + buildCssTextString(["display: none"]) + " }\n\n";
              style += "." + containerAnimationActiveClass + " { " + buildCssTextString(["-webkit-animation-duration: 0.1s", "animation-duration: 0.1s", "-webkit-animation-name: " + containerAnimationClass, "animation-name: " + containerAnimationClass]) + " }\n";
              style += "@-webkit-keyframes " + containerAnimationClass + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\n";
              style += "@keyframes " + containerAnimationClass + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }";
              injectStyle(style);
            }
          }
          function addAnimationClass(element) {
            element.className += " " + detectionContainerClass + "_animation_active";
          }
          function addEvent(el, name, cb) {
            if (el.addEventListener) {
              el.addEventListener(name, cb);
            } else if (el.attachEvent) {
              el.attachEvent("on" + name, cb);
            } else {
              return reporter.error("[scroll] Don't know how to add event listeners.");
            }
          }
          function removeEvent(el, name, cb) {
            if (el.removeEventListener) {
              el.removeEventListener(name, cb);
            } else if (el.detachEvent) {
              el.detachEvent("on" + name, cb);
            } else {
              return reporter.error("[scroll] Don't know how to remove event listeners.");
            }
          }
          function getExpandElement(element) {
            return getState(element).container.childNodes[0].childNodes[0].childNodes[0];
          }
          function getShrinkElement(element) {
            return getState(element).container.childNodes[0].childNodes[0].childNodes[1];
          }
          function addListener(element, listener) {
            var listeners = getState(element).listeners;
            if (!listeners.push) {
              throw new Error("Cannot add listener to an element that is not detectable.");
            }
            getState(element).listeners.push(listener);
          }
          function makeDetectable(options2, element, callback) {
            if (!callback) {
              callback = element;
              element = options2;
              options2 = null;
            }
            options2 = options2 || {};
            function debug() {
              if (options2.debug) {
                var args = Array.prototype.slice.call(arguments);
                args.unshift(idHandler.get(element), "Scroll: ");
                if (reporter.log.apply) {
                  reporter.log.apply(null, args);
                } else {
                  for (var i = 0; i < args.length; i++) {
                    reporter.log(args[i]);
                  }
                }
              }
            }
            function isDetached(element2) {
              function isInDocument(element3) {
                return element3 === element3.ownerDocument.body || element3.ownerDocument.body.contains(element3);
              }
              if (!isInDocument(element2)) {
                return true;
              }
              if (window.getComputedStyle(element2) === null) {
                return true;
              }
              return false;
            }
            function isUnrendered(element2) {
              var container = getState(element2).container.childNodes[0];
              var style = window.getComputedStyle(container);
              return !style.width || style.width.indexOf("px") === -1;
            }
            function getStyle() {
              var elementStyle = window.getComputedStyle(element);
              var style = {};
              style.position = elementStyle.position;
              style.width = element.offsetWidth;
              style.height = element.offsetHeight;
              style.top = elementStyle.top;
              style.right = elementStyle.right;
              style.bottom = elementStyle.bottom;
              style.left = elementStyle.left;
              style.widthCSS = elementStyle.width;
              style.heightCSS = elementStyle.height;
              return style;
            }
            function storeStartSize() {
              var style = getStyle();
              getState(element).startSize = {
                width: style.width,
                height: style.height
              };
              debug("Element start size", getState(element).startSize);
            }
            function initListeners() {
              getState(element).listeners = [];
            }
            function storeStyle() {
              debug("storeStyle invoked.");
              if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
              }
              var style = getStyle();
              getState(element).style = style;
            }
            function storeCurrentSize(element2, width, height) {
              getState(element2).lastWidth = width;
              getState(element2).lastHeight = height;
            }
            function getExpandChildElement(element2) {
              return getExpandElement(element2).childNodes[0];
            }
            function getWidthOffset() {
              return 2 * scrollbarSizes.width + 1;
            }
            function getHeightOffset() {
              return 2 * scrollbarSizes.height + 1;
            }
            function getExpandWidth(width) {
              return width + 10 + getWidthOffset();
            }
            function getExpandHeight(height) {
              return height + 10 + getHeightOffset();
            }
            function getShrinkWidth(width) {
              return width * 2 + getWidthOffset();
            }
            function getShrinkHeight(height) {
              return height * 2 + getHeightOffset();
            }
            function positionScrollbars(element2, width, height) {
              var expand = getExpandElement(element2);
              var shrink = getShrinkElement(element2);
              var expandWidth = getExpandWidth(width);
              var expandHeight = getExpandHeight(height);
              var shrinkWidth = getShrinkWidth(width);
              var shrinkHeight = getShrinkHeight(height);
              expand.scrollLeft = expandWidth;
              expand.scrollTop = expandHeight;
              shrink.scrollLeft = shrinkWidth;
              shrink.scrollTop = shrinkHeight;
            }
            function injectContainerElement() {
              var container = getState(element).container;
              if (!container) {
                container = document.createElement("div");
                container.className = detectionContainerClass;
                container.style.cssText = buildCssTextString(["visibility: hidden", "display: inline", "width: 0px", "height: 0px", "z-index: -1", "overflow: hidden", "margin: 0", "padding: 0"]);
                getState(element).container = container;
                addAnimationClass(container);
                element.appendChild(container);
                var onAnimationStart = function() {
                  getState(element).onRendered && getState(element).onRendered();
                };
                addEvent(container, "animationstart", onAnimationStart);
                getState(element).onAnimationStart = onAnimationStart;
              }
              return container;
            }
            function injectScrollElements() {
              function alterPositionStyles() {
                var style = getState(element).style;
                if (style.position === "static") {
                  element.style.setProperty("position", "relative", options2.important ? "important" : "");
                  var removeRelativeStyles = function(reporter2, element2, style2, property) {
                    function getNumericalValue(value2) {
                      return value2.replace(/[^-\d\.]/g, "");
                    }
                    var value = style2[property];
                    if (value !== "auto" && getNumericalValue(value) !== "0") {
                      reporter2.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element2);
                      element2.style[property] = 0;
                    }
                  };
                  removeRelativeStyles(reporter, element, style, "top");
                  removeRelativeStyles(reporter, element, style, "right");
                  removeRelativeStyles(reporter, element, style, "bottom");
                  removeRelativeStyles(reporter, element, style, "left");
                }
              }
              function getLeftTopBottomRightCssText(left, top, bottom, right) {
                left = !left ? "0" : left + "px";
                top = !top ? "0" : top + "px";
                bottom = !bottom ? "0" : bottom + "px";
                right = !right ? "0" : right + "px";
                return ["left: " + left, "top: " + top, "right: " + right, "bottom: " + bottom];
              }
              debug("Injecting elements");
              if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
              }
              alterPositionStyles();
              var rootContainer = getState(element).container;
              if (!rootContainer) {
                rootContainer = injectContainerElement();
              }
              var scrollbarWidth = scrollbarSizes.width;
              var scrollbarHeight = scrollbarSizes.height;
              var containerContainerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%", "left: 0px", "top: 0px"]);
              var containerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden"].concat(getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth)));
              var expandStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
              var shrinkStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
              var expandChildStyle = buildCssTextString(["position: absolute", "left: 0", "top: 0"]);
              var shrinkChildStyle = buildCssTextString(["position: absolute", "width: 200%", "height: 200%"]);
              var containerContainer = document.createElement("div");
              var container = document.createElement("div");
              var expand = document.createElement("div");
              var expandChild = document.createElement("div");
              var shrink = document.createElement("div");
              var shrinkChild = document.createElement("div");
              containerContainer.dir = "ltr";
              containerContainer.style.cssText = containerContainerStyle;
              containerContainer.className = detectionContainerClass;
              container.className = detectionContainerClass;
              container.style.cssText = containerStyle;
              expand.style.cssText = expandStyle;
              expandChild.style.cssText = expandChildStyle;
              shrink.style.cssText = shrinkStyle;
              shrinkChild.style.cssText = shrinkChildStyle;
              expand.appendChild(expandChild);
              shrink.appendChild(shrinkChild);
              container.appendChild(expand);
              container.appendChild(shrink);
              containerContainer.appendChild(container);
              rootContainer.appendChild(containerContainer);
              function onExpandScroll() {
                getState(element).onExpand && getState(element).onExpand();
              }
              function onShrinkScroll() {
                getState(element).onShrink && getState(element).onShrink();
              }
              addEvent(expand, "scroll", onExpandScroll);
              addEvent(shrink, "scroll", onShrinkScroll);
              getState(element).onExpandScroll = onExpandScroll;
              getState(element).onShrinkScroll = onShrinkScroll;
            }
            function registerListenersAndPositionElements() {
              function updateChildSizes(element2, width, height) {
                var expandChild = getExpandChildElement(element2);
                var expandWidth = getExpandWidth(width);
                var expandHeight = getExpandHeight(height);
                expandChild.style.setProperty("width", expandWidth + "px", options2.important ? "important" : "");
                expandChild.style.setProperty("height", expandHeight + "px", options2.important ? "important" : "");
              }
              function updateDetectorElements(done) {
                var width = element.offsetWidth;
                var height = element.offsetHeight;
                var sizeChanged = width !== getState(element).lastWidth || height !== getState(element).lastHeight;
                debug("Storing current size", width, height);
                storeCurrentSize(element, width, height);
                batchProcessor.add(0, function performUpdateChildSizes() {
                  if (!sizeChanged) {
                    return;
                  }
                  if (!getState(element)) {
                    debug("Aborting because element has been uninstalled");
                    return;
                  }
                  if (!areElementsInjected()) {
                    debug("Aborting because element container has not been initialized");
                    return;
                  }
                  if (options2.debug) {
                    var w = element.offsetWidth;
                    var h = element.offsetHeight;
                    if (w !== width || h !== height) {
                      reporter.warn(idHandler.get(element), "Scroll: Size changed before updating detector elements.");
                    }
                  }
                  updateChildSizes(element, width, height);
                });
                batchProcessor.add(1, function updateScrollbars() {
                  if (!getState(element)) {
                    debug("Aborting because element has been uninstalled");
                    return;
                  }
                  if (!areElementsInjected()) {
                    debug("Aborting because element container has not been initialized");
                    return;
                  }
                  positionScrollbars(element, width, height);
                });
                if (sizeChanged && done) {
                  batchProcessor.add(2, function() {
                    if (!getState(element)) {
                      debug("Aborting because element has been uninstalled");
                      return;
                    }
                    if (!areElementsInjected()) {
                      debug("Aborting because element container has not been initialized");
                      return;
                    }
                    done();
                  });
                }
              }
              function areElementsInjected() {
                return !!getState(element).container;
              }
              function notifyListenersIfNeeded() {
                function isFirstNotify() {
                  return getState(element).lastNotifiedWidth === void 0;
                }
                debug("notifyListenersIfNeeded invoked");
                var state = getState(element);
                if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {
                  return debug("Not notifying: Size is the same as the start size, and there has been no notification yet.");
                }
                if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {
                  return debug("Not notifying: Size already notified");
                }
                debug("Current size not notified, notifying...");
                state.lastNotifiedWidth = state.lastWidth;
                state.lastNotifiedHeight = state.lastHeight;
                forEach(getState(element).listeners, function(listener) {
                  listener(element);
                });
              }
              function handleRender() {
                debug("startanimation triggered.");
                if (isUnrendered(element)) {
                  debug("Ignoring since element is still unrendered...");
                  return;
                }
                debug("Element rendered.");
                var expand = getExpandElement(element);
                var shrink = getShrinkElement(element);
                if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {
                  debug("Scrollbars out of sync. Updating detector elements...");
                  updateDetectorElements(notifyListenersIfNeeded);
                }
              }
              function handleScroll() {
                debug("Scroll detected.");
                if (isUnrendered(element)) {
                  debug("Scroll event fired while unrendered. Ignoring...");
                  return;
                }
                updateDetectorElements(notifyListenersIfNeeded);
              }
              debug("registerListenersAndPositionElements invoked.");
              if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
              }
              getState(element).onRendered = handleRender;
              getState(element).onExpand = handleScroll;
              getState(element).onShrink = handleScroll;
              var style = getState(element).style;
              updateChildSizes(element, style.width, style.height);
            }
            function finalizeDomMutation() {
              debug("finalizeDomMutation invoked.");
              if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
              }
              var style = getState(element).style;
              storeCurrentSize(element, style.width, style.height);
              positionScrollbars(element, style.width, style.height);
            }
            function ready() {
              callback(element);
            }
            function install() {
              debug("Installing...");
              initListeners();
              storeStartSize();
              batchProcessor.add(0, storeStyle);
              batchProcessor.add(1, injectScrollElements);
              batchProcessor.add(2, registerListenersAndPositionElements);
              batchProcessor.add(3, finalizeDomMutation);
              batchProcessor.add(4, ready);
            }
            debug("Making detectable...");
            if (isDetached(element)) {
              debug("Element is detached");
              injectContainerElement();
              debug("Waiting until element is attached...");
              getState(element).onRendered = function() {
                debug("Element is now attached");
                install();
              };
            } else {
              install();
            }
          }
          function uninstall(element) {
            var state = getState(element);
            if (!state) {
              return;
            }
            state.onExpandScroll && removeEvent(getExpandElement(element), "scroll", state.onExpandScroll);
            state.onShrinkScroll && removeEvent(getShrinkElement(element), "scroll", state.onShrinkScroll);
            state.onAnimationStart && removeEvent(state.container, "animationstart", state.onAnimationStart);
            state.container && element.removeChild(state.container);
          }
          return {
            makeDetectable,
            addListener,
            uninstall,
            initDocument
          };
        };
      },
      "d6eb": function(module2, exports2, __webpack_require__) {
        "use strict";
        var prop = "_erd";
        function initState(element) {
          element[prop] = {};
          return getState(element);
        }
        function getState(element) {
          return element[prop];
        }
        function cleanState(element) {
          delete element[prop];
        }
        module2.exports = {
          initState,
          getState,
          cleanState
        };
      },
      "eec4": function(module2, exports2, __webpack_require__) {
        "use strict";
        var forEach = __webpack_require__("b770").forEach;
        var elementUtilsMaker = __webpack_require__("5be5");
        var listenerHandlerMaker = __webpack_require__("49ad");
        var idGeneratorMaker = __webpack_require__("2cef");
        var idHandlerMaker = __webpack_require__("5058");
        var reporterMaker = __webpack_require__("abb4");
        var browserDetector = __webpack_require__("18e9");
        var batchProcessorMaker = __webpack_require__("c274");
        var stateHandler = __webpack_require__("d6eb");
        var objectStrategyMaker = __webpack_require__("18d2");
        var scrollStrategyMaker = __webpack_require__("c946");
        function isCollection(obj) {
          return Array.isArray(obj) || obj.length !== void 0;
        }
        function toArray(collection) {
          if (!Array.isArray(collection)) {
            var array = [];
            forEach(collection, function(obj) {
              array.push(obj);
            });
            return array;
          } else {
            return collection;
          }
        }
        function isElement(obj) {
          return obj && obj.nodeType === 1;
        }
        module2.exports = function(options) {
          options = options || {};
          var idHandler;
          if (options.idHandler) {
            idHandler = {
              get: function(element) {
                return options.idHandler.get(element, true);
              },
              set: options.idHandler.set
            };
          } else {
            var idGenerator = idGeneratorMaker();
            var defaultIdHandler = idHandlerMaker({
              idGenerator,
              stateHandler
            });
            idHandler = defaultIdHandler;
          }
          var reporter = options.reporter;
          if (!reporter) {
            var quiet = reporter === false;
            reporter = reporterMaker(quiet);
          }
          var batchProcessor = getOption(options, "batchProcessor", batchProcessorMaker({ reporter }));
          var globalOptions = {};
          globalOptions.callOnAdd = !!getOption(options, "callOnAdd", true);
          globalOptions.debug = !!getOption(options, "debug", false);
          var eventListenerHandler = listenerHandlerMaker(idHandler);
          var elementUtils = elementUtilsMaker({
            stateHandler
          });
          var detectionStrategy;
          var desiredStrategy = getOption(options, "strategy", "object");
          var importantCssRules = getOption(options, "important", false);
          var strategyOptions = {
            reporter,
            batchProcessor,
            stateHandler,
            idHandler,
            important: importantCssRules
          };
          if (desiredStrategy === "scroll") {
            if (browserDetector.isLegacyOpera()) {
              reporter.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");
              desiredStrategy = "object";
            } else if (browserDetector.isIE(9)) {
              reporter.warn("Scroll strategy is not supported on IE9. Changing to object strategy.");
              desiredStrategy = "object";
            }
          }
          if (desiredStrategy === "scroll") {
            detectionStrategy = scrollStrategyMaker(strategyOptions);
          } else if (desiredStrategy === "object") {
            detectionStrategy = objectStrategyMaker(strategyOptions);
          } else {
            throw new Error("Invalid strategy name: " + desiredStrategy);
          }
          var onReadyCallbacks = {};
          function listenTo(options2, elements, listener) {
            function onResizeCallback(element) {
              var listeners = eventListenerHandler.get(element);
              forEach(listeners, function callListenerProxy(listener2) {
                listener2(element);
              });
            }
            function addListener(callOnAdd2, element, listener2) {
              eventListenerHandler.add(element, listener2);
              if (callOnAdd2) {
                listener2(element);
              }
            }
            if (!listener) {
              listener = elements;
              elements = options2;
              options2 = {};
            }
            if (!elements) {
              throw new Error("At least one element required.");
            }
            if (!listener) {
              throw new Error("Listener required.");
            }
            if (isElement(elements)) {
              elements = [elements];
            } else if (isCollection(elements)) {
              elements = toArray(elements);
            } else {
              return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
            }
            var elementsReady = 0;
            var callOnAdd = getOption(options2, "callOnAdd", globalOptions.callOnAdd);
            var onReadyCallback = getOption(options2, "onReady", function noop() {
            });
            var debug = getOption(options2, "debug", globalOptions.debug);
            forEach(elements, function attachListenerToElement(element) {
              if (!stateHandler.getState(element)) {
                stateHandler.initState(element);
                idHandler.set(element);
              }
              var id = idHandler.get(element);
              debug && reporter.log("Attaching listener to element", id, element);
              if (!elementUtils.isDetectable(element)) {
                debug && reporter.log(id, "Not detectable.");
                if (elementUtils.isBusy(element)) {
                  debug && reporter.log(id, "System busy making it detectable");
                  addListener(callOnAdd, element, listener);
                  onReadyCallbacks[id] = onReadyCallbacks[id] || [];
                  onReadyCallbacks[id].push(function onReady() {
                    elementsReady++;
                    if (elementsReady === elements.length) {
                      onReadyCallback();
                    }
                  });
                  return;
                }
                debug && reporter.log(id, "Making detectable...");
                elementUtils.markBusy(element, true);
                return detectionStrategy.makeDetectable({ debug, important: importantCssRules }, element, function onElementDetectable(element2) {
                  debug && reporter.log(id, "onElementDetectable");
                  if (stateHandler.getState(element2)) {
                    elementUtils.markAsDetectable(element2);
                    elementUtils.markBusy(element2, false);
                    detectionStrategy.addListener(element2, onResizeCallback);
                    addListener(callOnAdd, element2, listener);
                    var state = stateHandler.getState(element2);
                    if (state && state.startSize) {
                      var width = element2.offsetWidth;
                      var height = element2.offsetHeight;
                      if (state.startSize.width !== width || state.startSize.height !== height) {
                        onResizeCallback(element2);
                      }
                    }
                    if (onReadyCallbacks[id]) {
                      forEach(onReadyCallbacks[id], function(callback) {
                        callback();
                      });
                    }
                  } else {
                    debug && reporter.log(id, "Element uninstalled before being detectable.");
                  }
                  delete onReadyCallbacks[id];
                  elementsReady++;
                  if (elementsReady === elements.length) {
                    onReadyCallback();
                  }
                });
              }
              debug && reporter.log(id, "Already detecable, adding listener.");
              addListener(callOnAdd, element, listener);
              elementsReady++;
            });
            if (elementsReady === elements.length) {
              onReadyCallback();
            }
          }
          function uninstall(elements) {
            if (!elements) {
              return reporter.error("At least one element is required.");
            }
            if (isElement(elements)) {
              elements = [elements];
            } else if (isCollection(elements)) {
              elements = toArray(elements);
            } else {
              return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
            }
            forEach(elements, function(element) {
              eventListenerHandler.removeAllListeners(element);
              detectionStrategy.uninstall(element);
              stateHandler.cleanState(element);
            });
          }
          function initDocument(targetDocument) {
            detectionStrategy.initDocument && detectionStrategy.initDocument(targetDocument);
          }
          return {
            listenTo,
            removeListener: eventListenerHandler.removeListener,
            removeAllListeners: eventListenerHandler.removeAllListeners,
            uninstall,
            initDocument
          };
        };
        function getOption(options, name, defaultValue) {
          var value = options[name];
          if ((value === void 0 || value === null) && defaultValue !== void 0) {
            return defaultValue;
          }
          return value;
        }
      },
      "f6fd": function(module2, exports2) {
        (function(document2) {
          var currentScript = "currentScript", scripts = document2.getElementsByTagName("script");
          if (!(currentScript in document2)) {
            Object.defineProperty(document2, currentScript, {
              get: function() {
                try {
                  throw new Error();
                } catch (err) {
                  var i, res = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack) || [false])[1];
                  for (i in scripts) {
                    if (scripts[i].src == res || scripts[i].readyState == "interactive") {
                      return scripts[i];
                    }
                  }
                  return null;
                }
              }
            });
          }
        })(document);
      },
      "fb15": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "resize", function() {
          return elementResizeDetector;
        });
        if (typeof window !== "undefined") {
          if (true) {
            __webpack_require__("f6fd");
          }
          var i;
          if ((i = window.document.currentScript) && (i = i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
            __webpack_require__.p = i[1];
          }
        }
        var setPublicPath = null;
        var elementResizeDetectorMaker = __webpack_require__("eec4");
        var erd = elementResizeDetectorMaker({
          strategy: "scroll"
        });
        function bind(el, binding, vnode) {
          var options = {};
          if (binding.value) {
            options = binding.value;
          }
          erd.listenTo(options, el, function(element) {
            var width = element.offsetWidth;
            var height = element.offsetHeight;
            if (vnode.componentInstance) {
              vnode.componentInstance.$emit("resize", {
                detail: {
                  width,
                  height
                }
              });
            } else {
              vnode.elm.dispatchEvent(new CustomEvent("resize", {
                detail: {
                  width,
                  height
                }
              }));
            }
          });
        }
        function unbind(el) {
          erd.uninstall(el);
        }
        var elementResizeDetector = {
          bind,
          unbind
        };
        var src = {
          install: function install(Vue) {
            Vue.directive("resize", elementResizeDetector);
          }
        };
        var entry_lib = __webpack_exports__["default"] = src;
      }
    });
  }
});

// dep:vue-element-resize-detector
var vue_element_resize_detector_default = require_vue_element_resize_detector_common();
export {
  vue_element_resize_detector_default as default
};
//# sourceMappingURL=vue-element-resize-detector.js.map

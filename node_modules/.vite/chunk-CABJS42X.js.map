{
  "version": 3,
  "sources": ["../@interactjs/utils/domObjects.ts", "../@interactjs/utils/isWindow.ts", "../@interactjs/utils/window.ts", "../@interactjs/utils/is.ts", "../@interactjs/utils/browser.ts", "../@interactjs/utils/arr.ts", "../@interactjs/utils/clone.ts", "../@interactjs/utils/extend.ts", "../@interactjs/utils/raf.ts", "../@interactjs/utils/normalizeListeners.ts", "../@interactjs/core/Eventable.ts", "../@interactjs/utils/domUtils.ts", "../@interactjs/utils/rect.ts", "../@interactjs/utils/getOriginXY.ts", "../@interactjs/utils/hypot.ts", "../@interactjs/core/BaseEvent.ts", "../@interactjs/core/options.ts", "../@interactjs/core/InteractEvent.ts", "../@interactjs/utils/misc.ts", "../@interactjs/utils/pointerExtend.ts", "../@interactjs/utils/pointerUtils.ts", "../@interactjs/core/isNonNativeEvent.ts", "../@interactjs/core/InteractStatic.ts", "../@interactjs/core/Interactable.ts", "../@interactjs/core/InteractableSet.ts", "../@interactjs/core/events.ts", "../@interactjs/core/PointerInfo.ts", "../@interactjs/core/Interaction.ts", "../@interactjs/core/interactablePreventDefault.ts", "../@interactjs/core/interactionFinder.ts", "../@interactjs/core/interactions.ts", "../@interactjs/core/scope.ts", "../@interactjs/interact/index.ts"],
  "sourcesContent": ["const domObjects: {\n  init: any\n  document: Document\n  DocumentFragment: typeof DocumentFragment\n  SVGElement: typeof SVGElement\n  SVGSVGElement: typeof SVGSVGElement\n  SVGElementInstance: any\n  Element: typeof Element\n  HTMLElement: typeof HTMLElement\n  Event: typeof Event\n  Touch: typeof Touch\n  PointerEvent: typeof PointerEvent\n} = {\n  init,\n  document: null,\n  DocumentFragment: null,\n  SVGElement: null,\n  SVGSVGElement: null,\n  SVGElementInstance: null,\n  Element: null,\n  HTMLElement: null,\n  Event: null,\n  Touch: null,\n  PointerEvent: null,\n}\n\nfunction blank () {}\n\nexport default domObjects\n\nfunction init (window: Window) {\n  const win = window as any\n\n  domObjects.document = win.document\n  domObjects.DocumentFragment = win.DocumentFragment || blank\n  domObjects.SVGElement = win.SVGElement || blank\n  domObjects.SVGSVGElement = win.SVGSVGElement || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element = win.Element || blank\n  domObjects.HTMLElement = win.HTMLElement || domObjects.Element\n\n  domObjects.Event = win.Event\n  domObjects.Touch = win.Touch || blank\n  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent\n}\n", "export default (thing: any) => !!(thing && thing.Window) && thing instanceof thing.Window\n", "import isWindow from './isWindow'\n\nexport let realWindow = undefined as Window\n\nlet win = undefined as Window\nexport { win as window }\n\nexport function init (window: Window & { wrap?: (...args: any[]) => any }) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win = window\n}\n\nif (typeof window !== 'undefined' && !!window) {\n  init(window)\n}\n\nexport function getWindow (node: any) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = node.ownerDocument || node\n\n  return rootNode.defaultView || win.window\n}\n", "import type { Element } from '@interactjs/types/index'\n\nimport isWindow from './isWindow'\nimport * as win from './window'\n\nconst window = (thing: any): thing is Window => thing === win.window || isWindow(thing)\n\nconst docFrag = (thing: any): thing is DocumentFragment => object(thing) && thing.nodeType === 11\n\nconst object = (thing: any): thing is { [index: string]: any } => !!thing && typeof thing === 'object'\n\nconst func = (thing: any): thing is (...args: any[]) => any => typeof thing === 'function'\n\nconst number = (thing: any): thing is number => typeof thing === 'number'\n\nconst bool = (thing: any): thing is boolean => typeof thing === 'boolean'\n\nconst string = (thing: any): thing is string => typeof thing === 'string'\n\nconst element = (thing: any): thing is Element => {\n  if (!thing || typeof thing !== 'object') {\n    return false\n  }\n\n  // eslint-disable-next-line import/no-named-as-default-member\n  const _window = win.getWindow(thing) || win.window\n\n  return /object|function/.test(typeof _window.Element)\n    ? thing instanceof _window.Element // DOM2\n    : thing.nodeType === 1 && typeof thing.nodeName === 'string'\n}\n\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =>\n  object(thing) && !!thing.constructor && /function Object\\b/.test(thing.constructor.toString())\n\nconst array = <T extends unknown>(thing: any): thing is T[] =>\n  object(thing) && typeof thing.length !== 'undefined' && func(thing.splice)\n\nexport default {\n  window,\n  docFrag,\n  object,\n  func,\n  number,\n  bool,\n  string,\n  element,\n  plainObject,\n  array,\n}\n", "import domObjects from './domObjects'\nimport is from './is'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as 'matches',\n  pEventTypes: null as {\n    up: string\n    down: string\n    over: string\n    out: string\n    move: string\n    cancel: string\n  },\n  wheelEvent: null as string,\n}\n\nfunction init (window: any) {\n  const Element = domObjects.Element\n  const navigator: Partial<Navigator> = window.navigator || {}\n\n  // Does the browser support touch input?\n  browser.supportsTouch =\n    'ontouchstart' in window ||\n    (is.func(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch)\n\n  // Does the browser support PointerEvents\n  browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!domObjects.PointerEvent\n\n  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform)\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion)\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile =\n    navigator.appName === 'Opera' && browser.supportsTouch && /Presto/.test(navigator.userAgent)\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = ('matches' in Element.prototype\n    ? 'matches'\n    : 'webkitMatchesSelector' in Element.prototype\n      ? 'webkitMatchesSelector'\n      : 'mozMatchesSelector' in Element.prototype\n        ? 'mozMatchesSelector'\n        : 'oMatchesSelector' in Element.prototype\n          ? 'oMatchesSelector'\n          : 'msMatchesSelector') as 'matches'\n\n  browser.pEventTypes = browser.supportsPointerEvent\n    ? domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up: 'MSPointerUp',\n        down: 'MSPointerDown',\n        over: 'mouseover',\n        out: 'mouseout',\n        move: 'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up: 'pointerup',\n        down: 'pointerdown',\n        over: 'pointerover',\n        out: 'pointerout',\n        move: 'pointermove',\n        cancel: 'pointercancel',\n      }\n    : null\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = domObjects.document && 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n", "type Filter<T> = (element: T, index: number, array: T[]) => boolean\n\nexport const contains = <T>(array: T[], target: T) => array.indexOf(target) !== -1\n\nexport const remove = <T>(array: T[], target: T) => array.splice(array.indexOf(target), 1)\n\nexport const merge = <T, U>(target: Array<T | U>, source: U[]) => {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport const from = <T = any>(source: ArrayLike<T>) => merge([] as T[], source as T[])\n\nexport const findIndex = <T>(array: T[], func: Filter<T>) => {\n  for (let i = 0; i < array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport const find = <T = any>(array: T[], func: Filter<T>) => array[findIndex(array, func)]\n", "import * as arr from './arr'\nimport is from './is'\n\n// tslint:disable-next-line ban-types\nexport default function clone<T extends Object> (source: T): Partial<T> {\n  const dest = {} as Partial<T>\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    } else if (is.array(value)) {\n      dest[prop] = arr.from(value) as typeof value\n    } else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n", "export default function extend<T, U extends object> (dest: U & Partial<T>, source: T): T & U {\n  for (const prop in source) {\n    ;((dest as unknown) as T)[prop] = source[prop]\n  }\n\n  const ret = dest as T & U\n\n  return ret\n}\n", "let lastTime = 0\nlet request: typeof requestAnimationFrame\nlet cancel: typeof cancelAnimationFrame\n\nfunction init (global: Window | typeof globalThis) {\n  request = global.requestAnimationFrame\n  cancel = global.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = global[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\n      cancel =\n        global[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\n        global[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\n    }\n  }\n\n  request = request && request.bind(global)\n  cancel = cancel && cancel.bind(global)\n\n  if (!request) {\n    request = (callback) => {\n      const currTime = Date.now()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      const token = global.setTimeout(() => {\n        // eslint-disable-next-line node/no-callback-literal\n        callback(currTime + timeToCall)\n      }, timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token as any\n    }\n\n    cancel = (token) => clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback: FrameRequestCallback) => request(callback),\n  cancel: (token: number) => cancel(token),\n  init,\n}\n", "import type { EventTypes, Listener, ListenersArg } from '@interactjs/types/index'\n\nimport extend from './extend'\nimport is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Listener[]\n}\n\nexport default function normalize (\n  type: EventTypes,\n  listeners?: ListenersArg | ListenersArg[],\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) && type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    return type.reduce<NormalizedListeners>((acc, t) => extend(acc, normalize(t, listeners, result)), result)\n  }\n\n  // ({ type: fn }) -> ('', { type: fn })\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  } else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, result)\n    }\n  } else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map((p) => `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split (type: string) {\n  return type.trim().split(/ +/)\n}\n", "import type { Listener, ListenersArg, Rect } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport type { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\nimport normalize from '@interactjs/utils/normalizeListeners'\n\nfunction fireUntilImmediateStopped (event: any, listeners: Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) {\n      break\n    }\n\n    listener(event)\n  }\n}\n\nexport class Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor (options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire<T extends { type: string, propagationStopped?: boolean }> (event: T) {\n    let listeners: Listener[]\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) {\n        continue\n      }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  getRect (_element: Element): Rect {\n    return null\n  }\n}\n", "import type { Rect, Target, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains (parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents (node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo (element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Element) {\n  return (element as SVGElement).correspondingUseElement || element\n}\n\nexport function getScrollXY (relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect (element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n", "import type {\n  HasGetRect,\n  RectResolvable,\n  Rect,\n  Element,\n  Point,\n  FullRect,\n  EdgeOptions,\n} from '@interactjs/types'\n\nimport { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport is from './is'\n\nexport function getStringOptionResult (value: any, target: HasGetRect, element: Node) {\n  if (value === 'parent') {\n    return parentNode(element)\n  }\n\n  if (value === 'self') {\n    return target.getRect(element as Element)\n  }\n\n  return closest(element, value)\n}\n\nexport function resolveRectLike<T extends any[]> (\n  value: RectResolvable<T>,\n  target?: HasGetRect,\n  element?: Node,\n  functionArgs?: T,\n) {\n  let returnValue: any = value\n  if (is.string(returnValue)) {\n    returnValue = getStringOptionResult(returnValue, target, element)\n  } else if (is.func(returnValue)) {\n    returnValue = returnValue(...functionArgs)\n  }\n\n  if (is.element(returnValue)) {\n    returnValue = getElementRect(returnValue)\n  }\n\n  return returnValue as Rect\n}\n\nexport function rectToXY (rect: Rect | Point) {\n  return (\n    rect && {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    }\n  )\n}\n\nexport function xywhToTlbr<T extends Partial<Rect & Point>> (rect: T) {\n  if (rect && !('left' in rect && 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left = rect.x || 0\n    rect.top = rect.y || 0\n    rect.right = rect.right || rect.left + rect.width\n    rect.bottom = rect.bottom || rect.top + rect.height\n  }\n\n  return rect as Rect & T\n}\n\nexport function tlbrToXywh (rect: Rect & Partial<Point>) {\n  if (rect && !('x' in rect && 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x = rect.left || 0\n    rect.y = rect.top || 0\n    rect.width = rect.width || (rect.right || 0) - rect.x\n    rect.height = rect.height || (rect.bottom || 0) - rect.y\n  }\n\n  return rect as FullRect & Point\n}\n\nexport function addEdges (edges: EdgeOptions, rect: Rect, delta: Point) {\n  if (edges.left) {\n    rect.left += delta.x\n  }\n  if (edges.right) {\n    rect.right += delta.x\n  }\n  if (edges.top) {\n    rect.top += delta.y\n  }\n  if (edges.bottom) {\n    rect.bottom += delta.y\n  }\n\n  rect.width = rect.right - rect.left\n  rect.height = rect.bottom - rect.top\n}\n", "import type { PerActionDefaults } from '@interactjs/core/options'\nimport type { ActionName } from '@interactjs/core/scope'\nimport type { HasGetRect } from '@interactjs/types/index'\n\nimport { rectToXY, resolveRectLike } from './rect'\n\nexport default function (\n  target: HasGetRect & { options: PerActionDefaults },\n  element: Node,\n  actionName?: ActionName,\n) {\n  const actionOptions = (target.options as any)[actionName]\n  const actionOrigin = actionOptions && actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target && element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n", "export default (x: number, y: number) => Math.sqrt(x * x + y * y)\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\n\nexport class BaseEvent<T extends ActionName | null = never> {\n  type: string\n  target: EventTarget\n  currentTarget: Node\n  interactable: Interactable\n  _interaction: Interaction<T>\n  timeStamp: any\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  constructor (interaction: Interaction<T>) {\n    this._interaction = interaction\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface BaseEvent<T extends ActionName> {\n  interaction: InteractionProxy<T>\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\n  get (this: BaseEvent) {\n    return this._interaction._proxy\n  },\n  set (this: BaseEvent) {},\n})\n", "import type { Point, Listeners, OrBoolean, Element } from '@interactjs/types/index'\n\nexport interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionDefaults {}\n\nexport interface BaseDefaults {\n  preventDefault?: 'auto' | 'never' | string\n  deltaSource?: 'page' | 'client'\n  context?: Node\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Point | string | Element\n  listeners?: Listeners\n  allowFrom?: string | Element\n  ignoreFrom?: string | Element\n}\n\nexport type Options = Partial<BaseDefaults> &\nPartial<PerActionDefaults> &\n{\n  [P in keyof ActionDefaults]?: Partial<ActionDefaults[P]>\n}\n\n// export interface Options extends BaseDefaults, PerActionDefaults {}\n\nexport interface OptionsArg extends BaseDefaults, OrBoolean<Partial<ActionDefaults>> {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {} as ActionDefaults,\n}\n", "import type { ActionName } from '@interactjs/core/scope'\nimport type { Point, FullRect, PointerEventType, Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\n\nimport { BaseEvent } from './BaseEvent'\nimport type { Interaction } from './Interaction'\nimport { defaults } from './options'\n\nexport type EventPhase = keyof PhaseMap\n\nexport interface PhaseMap {\n  start: true\n  move: true\n  end: true\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface InteractEvent {\n  pageX: number\n  pageY: number\n\n  clientX: number\n  clientY: number\n\n  dx: number\n  dy: number\n\n  velocityX: number\n  velocityY: number\n}\n\nexport class InteractEvent<\n  T extends ActionName = never,\n  P extends EventPhase = EventPhase\n> extends BaseEvent<T> {\n  target: Element\n  currentTarget: Element\n  relatedTarget: Element | null = null\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  page: Point\n  client: Point\n  delta: Point\n  rect: FullRect\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Point\n  speed: number\n  swipe: ReturnType<InteractEvent<T>['getSwipe']>\n  timeStamp: any\n  // resize\n  axes?: 'x' | 'y' | 'xy'\n  preEnd?: boolean\n\n  /** */\n  constructor (\n    interaction: Interaction<T>,\n    event: PointerEventType,\n    actionName: T,\n    phase: P,\n    element: Element,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    super(interaction)\n\n    element = element || interaction.element\n\n    const target = interaction.interactable\n    const deltaSource = (((target && target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin = getOriginXY(target, element, actionName)\n    const starting = phase === 'start'\n    const ending = phase === 'end'\n    const prevEvent = starting ? this : interaction.prevEvent\n    const coords = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page = extend({}, coords.page)\n    this.client = extend({}, coords.client)\n    this.rect = extend({}, interaction.rect)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey = event.ctrlKey\n    this.altKey = event.altKey\n    this.shiftKey = event.shiftKey\n    this.metaKey = event.metaKey\n    this.button = (event as MouseEvent).button\n    this.buttons = (event as MouseEvent).buttons\n    this.target = element\n    this.currentTarget = element\n    this.preEnd = preEnd\n    this.type = type || actionName + (phase || '')\n    this.interactable = target\n\n    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0\n\n    this.x0 = interaction.coords.start.page.x - origin.x\n    this.y0 = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    } else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt = interaction.coords.delta.timeStamp\n    this.duration = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null\n  }\n\n  getSwipe () {\n    const interaction = this._interaction\n\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null\n    }\n\n    let angle = (180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX)) / Math.PI\n    const overlap = 22.5\n\n    if (angle < 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap\n    const up = 225 - overlap <= angle && angle < 315 + overlap\n\n    const right = !left && (315 - overlap <= angle || angle < 45 + overlap)\n    const down = !up && 45 - overlap <= angle && angle < 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperties(InteractEvent.prototype, {\n  pageX: {\n    get () {\n      return this.page.x\n    },\n    set (value) {\n      this.page.x = value\n    },\n  },\n  pageY: {\n    get () {\n      return this.page.y\n    },\n    set (value) {\n      this.page.y = value\n    },\n  },\n\n  clientX: {\n    get () {\n      return this.client.x\n    },\n    set (value) {\n      this.client.x = value\n    },\n  },\n  clientY: {\n    get () {\n      return this.client.y\n    },\n    set (value) {\n      this.client.y = value\n    },\n  },\n\n  dx: {\n    get () {\n      return this.delta.x\n    },\n    set (value) {\n      this.delta.x = value\n    },\n  },\n  dy: {\n    get () {\n      return this.delta.y\n    },\n    set (value) {\n      this.delta.y = value\n    },\n  },\n\n  velocityX: {\n    get () {\n      return this.velocity.x\n    },\n    set (value) {\n      this.velocity.x = value\n    },\n  },\n  velocityY: {\n    get () {\n      return this.velocity.y\n    },\n    set (value) {\n      this.velocity.y = value\n    },\n  },\n})\n", "import type { ActionProps } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\n\nimport { window } from './window'\n\nexport function warnOnce<T> (this: T, method: (...args: any[]) => any, message: string) {\n  let warned = false\n\n  return function (this: T) {\n    if (!warned) {\n      ;(window as any).console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nexport function copyAction<T extends ActionName> (dest: ActionProps<any>, src: ActionProps<T>) {\n  dest.name = src.name\n  dest.axis = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n\nexport const sign = (n: number) => (n >= 0 ? 1 : -1)\n", "function pointerExtend<T> (dest: Partial<T>, source: T) {\n  for (const prop in source) {\n    const prefixedPropREs = pointerExtend.prefixedPropREs\n    let deprecated = false\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true\n        break\n      }\n    }\n\n    if (!deprecated && typeof source[prop] !== 'function') {\n      dest[prop] = source[prop]\n    }\n  }\n  return dest\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n  moz: /(Pressure)$/,\n} as { [prefix: string]: RegExp }\n\nexport default pointerExtend\n", "import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { CoordsSetMember, PointerType, Point, PointerEventType, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport is from './is'\nimport pointerExtend from './pointerExtend'\n\nexport function copyCoords (dest: CoordsSetMember, src: CoordsSetMember) {\n  dest.page = dest.page || ({} as any)\n  dest.page.x = src.page.x\n  dest.page.y = src.page.y\n\n  dest.client = dest.client || ({} as any)\n  dest.client.x = src.client.x\n  dest.client.y = src.client.y\n\n  dest.timeStamp = src.timeStamp\n}\n\nexport function setCoordDeltas (targetObj: CoordsSetMember, prev: CoordsSetMember, cur: CoordsSetMember) {\n  targetObj.page.x = cur.page.x - prev.page.x\n  targetObj.page.y = cur.page.y - prev.page.y\n  targetObj.client.x = cur.client.x - prev.client.x\n  targetObj.client.y = cur.client.y - prev.client.y\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n}\n\nexport function setCoordVelocity (targetObj: CoordsSetMember, delta: CoordsSetMember) {\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n  targetObj.page.x = delta.page.x / dt\n  targetObj.page.y = delta.page.y / dt\n  targetObj.client.x = delta.client.x / dt\n  targetObj.client.y = delta.client.y / dt\n  targetObj.timeStamp = dt\n}\n\nexport function setZeroCoords (targetObj: CoordsSetMember) {\n  targetObj.page.x = 0\n  targetObj.page.y = 0\n  targetObj.client.x = 0\n  targetObj.client.y = 0\n}\n\nexport function isNativePointer (pointer: any) {\n  return pointer instanceof dom.Event || pointer instanceof dom.Touch\n}\n\n// Get specified X/Y coords for mouse or event.touches[0]\nexport function getXY (type: string, pointer: PointerType | InteractEvent, xy: Point) {\n  xy = xy || ({} as Point)\n  type = type || 'page'\n\n  xy.x = pointer[(type + 'X') as keyof PointerType]\n  xy.y = pointer[(type + 'Y') as keyof PointerType]\n\n  return xy\n}\n\nexport function getPageXY (pointer: PointerType | InteractEvent, page?: Point) {\n  page = page || { x: 0, y: 0 }\n\n  // Opera Mobile handles the viewport and scrolling oddly\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    getXY('screen', pointer, page)\n\n    page.x += window.scrollX\n    page.y += window.scrollY\n  } else {\n    getXY('page', pointer, page)\n  }\n\n  return page\n}\n\nexport function getClientXY (pointer: PointerType, client: Point) {\n  client = client || ({} as any)\n\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    // Opera Mobile handles the viewport and scrolling oddly\n    getXY('screen', pointer, client)\n  } else {\n    getXY('client', pointer, client)\n  }\n\n  return client\n}\n\nexport function getPointerId (pointer: { pointerId?: number, identifier?: number, type?: string }) {\n  return is.number(pointer.pointerId) ? pointer.pointerId! : pointer.identifier!\n}\n\nexport function setCoords (dest: CoordsSetMember, pointers: any[], timeStamp: number) {\n  const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0]\n\n  getPageXY(pointer, dest.page)\n  getClientXY(pointer, dest.client)\n\n  dest.timeStamp = timeStamp\n}\n\nexport function getTouchPair (event: TouchEvent | PointerType[]) {\n  const touches: PointerType[] = []\n\n  // array of touches is supplied\n  if (is.array(event)) {\n    touches[0] = event[0]\n    touches[1] = event[1]\n  }\n  // an event\n  else {\n    if (event.type === 'touchend') {\n      if (event.touches.length === 1) {\n        touches[0] = event.touches[0]\n        touches[1] = event.changedTouches[0]\n      } else if (event.touches.length === 0) {\n        touches[0] = event.changedTouches[0]\n        touches[1] = event.changedTouches[1]\n      }\n    } else {\n      touches[0] = event.touches[0]\n      touches[1] = event.touches[1]\n    }\n  }\n\n  return touches\n}\n\nexport function pointerAverage (pointers: PointerType[]) {\n  const average = {\n    pageX: 0,\n    pageY: 0,\n    clientX: 0,\n    clientY: 0,\n    screenX: 0,\n    screenY: 0,\n  }\n\n  type CoordKeys = keyof typeof average\n\n  for (const pointer of pointers) {\n    for (const prop in average) {\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\n    }\n  }\n  for (const prop in average) {\n    average[prop as CoordKeys] /= pointers.length\n  }\n\n  return average\n}\n\nexport function touchBBox (event: PointerType[]) {\n  if (!event.length) {\n    return null\n  }\n\n  const touches = getTouchPair(event)\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n  return {\n    x: minX,\n    y: minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nexport function touchDistance (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n\n  const dx = touches[0][sourceX] - touches[1][sourceX]\n  const dy = touches[0][sourceY] - touches[1][sourceY]\n\n  return hypot(dx, dy)\n}\n\nexport function touchAngle (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n  const dx = touches[1][sourceX] - touches[0][sourceX]\n  const dy = touches[1][sourceY] - touches[0][sourceY]\n  const angle = (180 * Math.atan2(dy, dx)) / Math.PI\n\n  return angle\n}\n\nexport function getPointerType (pointer: { pointerType?: string, identifier?: number, type?: string }) {\n  return is.string(pointer.pointerType)\n    ? pointer.pointerType\n    : is.number(pointer.pointerType)\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]!\n      : // if the PointerEvent API isn't available, then the \"pointer\" must\n    // be either a MouseEvent, TouchEvent, or Touch object\n      /touch/.test(pointer.type || '') || pointer instanceof dom.Touch\n        ? 'touch'\n        : 'mouse'\n}\n\n// [ event.target, event.currentTarget ]\nexport function getEventTargets (event: Event) {\n  const path = is.func(event.composedPath)\n    ? (event.composedPath() as Element[])\n    : ((event as unknown) as { path: Element[] }).path\n\n  return [\n    domUtils.getActualElement(path ? path[0] : (event.target as Element)),\n    domUtils.getActualElement(event.currentTarget as Element),\n  ]\n}\n\nexport function newCoords (): CoordsSetMember {\n  return {\n    page: { x: 0, y: 0 },\n    client: { x: 0, y: 0 },\n    timeStamp: 0,\n  }\n}\n\nexport function coordsToEvent (coords: MockCoords) {\n  const event = {\n    coords,\n    get page () {\n      return this.coords.page\n    },\n    get client () {\n      return this.coords.client\n    },\n    get timeStamp () {\n      return this.coords.timeStamp\n    },\n    get pageX () {\n      return this.coords.page.x\n    },\n    get pageY () {\n      return this.coords.page.y\n    },\n    get clientX () {\n      return this.coords.client.x\n    },\n    get clientY () {\n      return this.coords.client.y\n    },\n    get pointerId () {\n      return this.coords.pointerId\n    },\n    get target () {\n      return this.coords.target\n    },\n    get type () {\n      return this.coords.type\n    },\n    get pointerType () {\n      return this.coords.pointerType\n    },\n    get buttons () {\n      return this.coords.buttons\n    },\n    preventDefault () {},\n  }\n\n  return event as typeof event & PointerType & PointerEventType\n}\n\nexport interface MockCoords {\n  page: Point\n  client: Point\n  timeStamp?: number\n  pointerId?: any\n  target?: any\n  type?: string\n  pointerType?: string\n  buttons?: number\n}\n\nexport { pointerExtend }\n", "import type { Actions } from '@interactjs/core/scope'\n\nexport default function isNonNativeEvent (type: string, actions: Actions) {\n  if (actions.phaselessTypes[type]) {\n    return true\n  }\n\n  for (const name in actions.map) {\n    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {\n      return true\n    }\n  }\n\n  return false\n}\n", "/** @module interact */\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Context, EventTypes, Listener, ListenersArg, Target, Element } from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Interactable } from './Interactable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { Options } from './options'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    (target: Target, options?: Options): Interactable\n    getPointerAverage: typeof pointerUtils.pointerAverage\n    getTouchBBox: typeof pointerUtils.touchBBox\n    getTouchDistance: typeof pointerUtils.touchDistance\n    getTouchAngle: typeof pointerUtils.touchAngle\n    getElementRect: typeof domUtils.getElementRect\n    getElementClientRect: typeof domUtils.getElementClientRect\n    matchesSelector: typeof domUtils.matchesSelector\n    closest: typeof domUtils.closest\n    /** @internal */ globalEvents: any\n    version: string\n    /** @internal */ scope: Scope\n    use(\n      plugin: Plugin,\n      options?: {\n        [key: string]: any\n      },\n    ): any\n    isSet(target: Element, options?: any): boolean\n    on(type: string | EventTypes, listener: ListenersArg, options?: object): any\n    off(type: EventTypes, listener: any, options?: object): any\n    debug(): any\n    supportsTouch(): boolean\n    supportsPointerEvent(): boolean\n    stop(): any\n    pointerMoveTolerance(newValue?: number): any\n    addDocument(doc: Document, options?: object): void\n    removeDocument(doc: Document): void\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\ntype _InteractStatic = import('@interactjs/core/InteractStatic').InteractStatic\n\nexport function createInteractStatic (scope: Scope): _InteractStatic {\n  /**\n   * ```js\n   * interact('#draggable').draggable(true)\n   *\n   * var rectables = interact('rect')\n   * rectables\n   *   .gesturable(true)\n   *   .on('gesturemove', function (event) {\n   *       // ...\n   *   })\n   * ```\n   *\n   * The methods of this variable can be used to set elements as interactables\n   * and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to configure\n   * it.\n   *\n   * @global\n   *\n   * @param {Element | string} target The HTML or SVG Element to interact with\n   * or CSS selector\n   * @return {Interactable}\n   */\n  const interact = ((target: Target, options: Options) => {\n    let interactable = scope.interactables.get(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as _InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  /**\n   * Use a plugin\n   *\n   * @alias module:interact.use\n   *\n   */\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  /**\n   * Check if an element or selector has been set with the {@link interact}\n   * function\n   *\n   * @alias module:interact.isSet\n   *\n   * @param {Target} target The Element or string being searched for\n   * @param {object} options\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  interact.isSet = function (target: Target, options?: { context?: Context }): boolean {\n    return !!this.scope.interactables.get(target, options && options.context)\n  }\n\n  /**\n   * @deprecated\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\n   *\n   * @alias module:interact.on\n   *\n   * @param {string | array | object} type The types of events to listen for\n   * @param {function} listener The function event (s)\n   * @param {object | boolean} [options] object or useCapture flag for\n   * addEventListener\n   * @return {object} interact\n   */\n  interact.on = warnOnce(function on (type: string | EventTypes, listener: ListenersArg, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type as any[]) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      } else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Listener, { options })\n    }\n\n    return this\n  }, 'The interact.on() method is being deprecated')\n\n  /**\n   * @deprecated\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   * @alias module:interact.off\n   *\n   * @param {string | array | object} type The types of events that were listened\n   * for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} options [options] object or useCapture flag for\n   * removeEventListener\n   * @return {object} interact\n   */\n  interact.off = warnOnce(function off (type: EventTypes, listener: any, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    } else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }, 'The interact.off() method is being deprecated')\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  /**\n   * @alias module:interact.supportsTouch\n   *\n   * @return {boolean} Whether or not the browser supports touch input\n   */\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  /**\n   * @alias module:interact.supportsPointerEvent\n   *\n   * @return {boolean} Whether or not the browser supports PointerEvents\n   */\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  /**\n   * Cancels all interactions (end events are not fired)\n   *\n   * @alias module:interact.stop\n   *\n   * @return {object} interact\n   */\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   * @alias module:interact.pointerMoveTolerance\n   *\n   * @param {number} [newValue] The movement from the start position must be greater than this value\n   * @return {interact | number}\n   */\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact\n}\n", "/* eslint-disable no-dupe-class-members */\nimport type { ActionMap, ActionName, Actions, Scope } from '@interactjs/core/scope'\nimport type {\n  Context,\n  Element,\n  Target,\n  Listeners,\n  OrBoolean,\n  EventTypes,\n  ListenersArg,\n  ActionMethod,\n} from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults } from './options'\nimport { Options } from './options'\n\ntype IgnoreValue = string | Element | boolean\ntype DeltaSource = 'page' | 'client'\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  /** @internal */ get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required<Options>\n  readonly _actions: Actions\n  readonly target: Target\n  readonly events = new Eventable()\n  readonly _context: Context\n  readonly _win: Window\n  readonly _doc: Document\n  readonly _scopeEvents: Scope['events']\n\n  /** @internal */ _rectChecker?: typeof Interactable.prototype.getRect\n\n  /** */\n  constructor (\n    target: Target,\n    options: any,\n    defaultContext: Document | Element,\n    scopeEvents: Scope['events'],\n  ) {\n    this._actions = options.actions\n    this.target = target\n    this._context = options.context || defaultContext\n    this._win = getWindow(trySelector(target) ? this._context : target)\n    this._doc = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) {\n      this.on(`${actionName}start`, phases.onstart)\n    }\n    if (is.func(phases.onmove)) {\n      this.on(`${actionName}move`, phases.onmove)\n    }\n    if (is.func(phases.onend)) {\n      this.on(`${actionName}end`, phases.onend)\n    }\n    if (is.func(phases.oninertiastart)) {\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\n    }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: ActionName, prev: Listeners, cur: Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: ActionName, options: OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array(optionValue)) {\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        ;(actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || ({} as any),\n          clone(optionValue),\n        )\n\n        // set anabled field to true if it exists in the defaults\n        if (\n          is.object(defaults.perAction[optionName]) &&\n          'enabled' in (defaults.perAction[optionName] as any)\n        ) {\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        ;(actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        ;(actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Rect} The object's bounding rectangle.\n   */\n  getRect (element: Element) {\n    element = element || (is.element(this.target) ? this.target : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker(): (element: Element) => any | null\n  rectChecker(checker: (element: Element) => any): this\n  rectChecker (checker?: (element: Element) => any) {\n    if (is.func(checker)) {\n      this._rectChecker = checker\n\n      this.getRect = (element) => {\n        const rect = extend({}, this._rectChecker(element))\n\n        if (!(('width' in rect) as unknown)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n      delete this._rectChecker\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      ;(this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource(): DeltaSource\n  deltaSource(newValue: DeltaSource): this\n  deltaSource (newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\n    )\n  }\n\n  testAllow (this: Interactable, allowFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!allowFrom) {\n      return true\n    }\n\n    if (!is.element(element)) {\n      return false\n    }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    } else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (this: Interactable, ignoreFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!ignoreFrom || !is.element(element)) {\n      return false\n    }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    } else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire<E extends { type: string }> (iEvent: E) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: EventTypes, listenerArg?: ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') {\n        type = browser.wheelEvent\n      }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](\n            this.target,\n            this._context,\n            type,\n            listener,\n            options,\n          )\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    ;(this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n      ;(this[methodName] as ActionMethod<unknown>)(options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func((this as any)[setting])) {\n        ;(this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(\n              this.target,\n              this._context,\n              type,\n              listeners[l][0],\n              listeners[l][1],\n            )\n          }\n        }\n      }\n    } else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { OptionsArg, Options } from '@interactjs/core/options'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Target, Context } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactable:new': {\n      interactable: Interactable\n      target: Target\n      options: OptionsArg\n      win: Window\n    }\n  }\n}\n\ninterface InteractableScopeProp {\n  context: Context\n  interactable: Interactable\n}\n\nexport class InteractableSet {\n  // all set interactables\n  list: Interactable[] = []\n\n  selectorMap: {\n    [selector: string]: InteractableScopeProp[]\n  } = {}\n\n  scope: Scope\n\n  constructor (scope: Scope) {\n    this.scope = scope\n    scope.addListeners({\n      'interactable:unset': ({ interactable }) => {\n        const { target, _context: context } = interactable\n        const targetMappings: InteractableScopeProp[] = is.string(target)\n          ? this.selectorMap[target]\n          : (target as any)[this.scope.id]\n\n        const targetIndex = arr.findIndex(targetMappings, (m) => m.context === context)\n        if (targetMappings[targetIndex]) {\n          // Destroying mappingInfo's context and interactable\n          targetMappings[targetIndex].context = null\n          targetMappings[targetIndex].interactable = null\n        }\n        targetMappings.splice(targetIndex, 1)\n      },\n    })\n  }\n\n  new (target: Target, options?: any): Interactable {\n    options = extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\n    const mappingInfo = { context: interactable._context, interactable }\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    if (is.string(target)) {\n      if (!this.selectorMap[target]) {\n        this.selectorMap[target] = []\n      }\n      this.selectorMap[target].push(mappingInfo)\n    } else {\n      if (!(interactable.target as any)[this.scope.id]) {\n        Object.defineProperty(target, this.scope.id, {\n          value: [],\n          configurable: true,\n        })\n      }\n\n      ;(target as any)[this.scope.id].push(mappingInfo)\n    }\n\n    this.scope.fire('interactable:new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  get (target: Target, options?: Options) {\n    const context = (options && options.context) || this.scope.document\n    const isSelector = is.string(target)\n    const targetMappings: InteractableScopeProp[] = isSelector\n      ? this.selectorMap[target as string]\n      : (target as any)[this.scope.id]\n\n    if (!targetMappings) {\n      return null\n    }\n\n    const found = arr.find(\n      targetMappings,\n      (m) => m.context === context && (isSelector || m.interactable.inContext(target as any)),\n    )\n\n    return found && found.interactable\n  }\n\n  forEachMatch<T> (node: Node, callback: (interactable: Interactable) => T) {\n    for (const interactable of this.list) {\n      let ret: void | T\n\n      if (\n        (is.string(interactable.target)\n          ? // target is a selector and the element matches\n          is.element(node) && domUtils.matchesSelector(node, interactable.target)\n          : // target is the element\n          node === interactable.target) &&\n        // the element is in context\n        interactable.inContext(node)\n      ) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n", "import type { Scope } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ntype Listener = (event: Event | FakeEvent) => any\n\nfunction install (scope: Scope) {\n  const targets: Array<{\n    eventTarget: EventTarget\n    events: { [type: string]: Listener[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: Array<[Listener, { capture: boolean, passive: boolean }]>\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document?.createElement('div').addEventListener('test', null, {\n    get capture () {\n      return (eventsMethods.supportsOptions = true)\n    },\n    get passive () {\n      return (eventsMethods.supportsPassive = true)\n    },\n  })\n\n  scope.events = eventsMethods\n\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, (t) => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (eventTarget.addEventListener && !arr.contains(target.events[type], listener)) {\n      eventTarget.addEventListener(\n        type,\n        listener as any,\n        eventsMethods.supportsOptions ? options : options.capture,\n      )\n      target.events[type].push(listener)\n    }\n  }\n\n  function remove (\n    eventTarget: EventTarget,\n    type: string,\n    listener?: 'all' | Listener,\n    optionalArg?: boolean | any,\n  ) {\n    const options = getOptions(optionalArg)\n    const targetIndex = arr.findIndex(targets, (t) => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          remove(eventTarget, type, typeListeners[i], options)\n        }\n        return\n      } else {\n        for (let i = 0; i < typeListeners.length; i++) {\n          if (typeListeners[i] === listener) {\n            eventTarget.removeEventListener(\n              type,\n              listener as any,\n              eventsMethods.supportsOptions ? options : options.capture,\n            )\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, (d) => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push([listener, options])\n  }\n\n  function removeDelegate (\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: Listener,\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) return\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const [fn, { capture, passive }] = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (fn === listener && capture === options.capture && passive === options.passive) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) {\n          break\n        }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (\n          domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)\n        ) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const [fn, { capture, passive }] of listeners) {\n            if (capture === options.capture && passive === options.passive) {\n              fn(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture (this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor (originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\n  if (!is.object(param)) {\n    return { capture: !!param, passive: false }\n  }\n\n  const options = extend({}, param) as any\n\n  options.capture = !!param.capture\n  options.passive = !!param.passive\n\n  return options\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n", "import type { PointerEventType, PointerType } from '@interactjs/types/index'\n\nexport class PointerInfo {\n  id: number\n  pointer: PointerType\n  event: PointerEventType\n  downTime: number\n  downTarget: Node\n\n  constructor (id: number, pointer: PointerType, event: PointerEventType, downTime: number, downTarget: Node) {\n    this.id = id\n    this.pointer = pointer\n    this.event = event\n    this.downTime = downTime\n    this.downTarget = downTarget\n  }\n}\n", "import type { ActionDefaults } from '@interactjs/core/options'\nimport type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n} from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport type { ActionName, Scope } from './scope'\n\nexport interface ActionProps<T extends ActionName | null = never> {\n  name: T\n  axis?: 'x' | 'y' | 'xy' | null\n  edges?: EdgeOptions | null\n}\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<never>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction<never>, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName | null = never> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName | null = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable = null\n\n  // the target element of the interactable\n  element: Element = null\n  rect: FullRect\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  edges: EdgeOptions\n\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: PointerEventType = null\n\n  downPointer: PointerType = {} as PointerType\n\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: { pointerType?: string, scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: (this as unknown) as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start<A extends ActionName> (action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &&\n      this.coords.cur.page.y === this.coords.prev.page.y &&\n      this.coords.cur.client.x === this.coords.prev.client.x &&\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: (this as unknown) as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: (this as unknown) as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: PointerType) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map((p) => p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: (this as unknown) as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (\n    signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerEventType } from '@interactjs/types/index'\nimport { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    preventDefault: typeof preventDefault\n    checkAndPreventDefault: (event: Event) => void\n  }\n}\n\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\nfunction preventDefault(this: Interactable): PreventDefaultValue\nfunction preventDefault(this: Interactable, newValue: PreventDefaultValue): typeof this\nfunction preventDefault (this: Interactable, newValue?: PreventDefaultValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue\n    return this\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never'\n    return this\n  }\n\n  return this.options.preventDefault\n}\n\nfunction checkAndPreventDefault (interactable: Interactable, scope: Scope, event: Event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') return\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (\n    is.element(event.target) &&\n    matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')\n  ) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent ({ interaction, event }: { interaction: Interaction, event: PointerEventType }) {\n  if (interaction.interactable) {\n    interaction.interactable.checkAndPreventDefault(event as Event)\n  }\n}\n\nexport function install (scope: Scope) {\n  /** @lends Interactable */\n  const { Interactable } = scope\n\n  /**\n   * Returns or sets whether to prevent the browser's default behaviour in\n   * response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\n   * @return {string | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.preventDefault = preventDefault\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.docEvents.push({\n    type: 'dragstart',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        if (\n          interaction.element &&\n          (interaction.element === event.target || nodeContains(interaction.element, event.target))\n        ) {\n          interaction.interactable.checkAndPreventDefault(event)\n          return\n        }\n      }\n    },\n  })\n}\n\nexport default {\n  id: 'core/interactablePreventDefault',\n  install,\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) => {\n    acc[`interactions:${eventType}`] = onInteractionEvent\n    return acc\n  }, {} as any),\n}\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search (details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume ({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer ({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle ({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId (interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n", "import type { Scope, ActionName, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Listener } from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport InteractionBase from './Interaction'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport type { SearchDetails } from './interactionFinder'\nimport finder from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: <T extends ActionName>(options: any) => InteractionBase<T>\n      list: Array<InteractionBase<ActionName>>\n      listeners: { [type: string]: Listener }\n      docEvents: Array<{ type: string, listener: Listener }>\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown',\n  'pointerMove',\n  'pointerUp',\n  'updatePointer',\n  'removePointer',\n  'windowBlur',\n]\n\nfunction install (scope: Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down, listener: listeners.pointerDown },\n      { type: pEventTypes.move, listener: listeners.pointerMove },\n      { type: pEventTypes.up, listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  } else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class <T extends ActionName> extends InteractionBase<T> {\n    get pointerMoveTolerance () {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance (value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now () {\n      return scope.now()\n    }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new<T extends ActionName> (options: { pointerType?: string, scopeFire?: Scope['fire'] }) {\n      options.scopeFire = (name, arg) => scope.fire(name, arg)\n\n      const interaction = new scope.Interaction<T>(options as Required<typeof options>)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls () {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) => nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions (method: string, scope: Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches: any[] = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    } else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer =\n          invalidPointer ||\n          scope.now() - scope.prevTouchTime < 500 ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction (searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal<T extends 'scope:add-document' | 'scope:remove-document'> (\n  { doc, scope, options }: SignalArgs[T],\n  eventMethodName: 'add' | 'remove',\n) {\n  const {\n    interactions: { docEvents },\n    events,\n  } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': (arg) => onDocSignal(arg, 'add'),\n    'scope:remove-document': (arg) => onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) => {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) {\n          continue\n        }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length > 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n", "import type Interaction from '@interactjs/core/Interaction'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport domObjects from '@interactjs/utils/domObjects'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport * as win from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport type { PhaseMap } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport { createInteractStatic } from './InteractStatic'\nimport type { Interactable } from './Interactable'\nimport { Interactable as InteractableBase } from './Interactable'\nimport { InteractableSet } from './InteractableSet'\nimport events from './events'\nimport interactions from './interactions'\nimport type { OptionsArg } from './options'\nimport { defaults } from './options'\n\nexport interface SignalArgs {\n  'scope:add-document': DocSignalArg\n  'scope:remove-document': DocSignalArg\n  'interactable:unset': { interactable: InteractableBase }\n  'interactable:set': { interactable: InteractableBase, options: OptionsArg }\n  'interactions:destroy': { interaction: Interaction }\n}\n\nexport type ListenerName = keyof SignalArgs\n\nexport type ListenerMap = {\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) => void | boolean\n}\n\ninterface DocSignalArg {\n  doc: Document\n  window: Window\n  scope: Scope\n  options: Record<string, any>\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionMap {}\nexport type ActionName = keyof ActionMap\n\nexport interface Actions {\n  map: ActionMap\n  phases: PhaseMap\n  methodDict: { [P in ActionName]?: keyof Interactable }\n  phaselessTypes: { [type: string]: true }\n}\n\nexport interface Plugin {\n  [key: string]: any\n  id?: string\n  listeners?: ListenerMap\n  before?: string[]\n  install?(scope: Scope, options?: any): void\n}\n\nexport class Scope {\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\n  isInitialized = false\n  listenerMaps: Array<{\n    map: ListenerMap\n    id: string\n  }> = []\n\n  browser = browser\n  defaults = clone(defaults) as typeof defaults\n  Eventable = Eventable\n  actions: Actions = {\n    map: {},\n    phases: {\n      start: true,\n      move: true,\n      end: true,\n    },\n    methodDict: {},\n    phaselessTypes: {},\n  }\n\n  interactStatic = createInteractStatic(this)\n  InteractEvent = InteractEvent\n  Interactable: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // main window\n  window!: Window\n\n  // all documents being listened to\n  documents: Array<{ doc: Document, options: any }> = []\n\n  _plugins: {\n    list: Plugin[]\n    map: { [id: string]: Plugin }\n  } = {\n    list: [],\n    map: {},\n  }\n\n  constructor () {\n    const scope = this\n\n    this.Interactable = class extends InteractableBase {\n      get _defaults () {\n        return scope.defaults\n      }\n\n      set<T extends InteractableBase> (this: T, options: OptionsArg) {\n        super.set(options)\n\n        scope.fire('interactable:set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset (this: InteractableBase) {\n        super.unset()\n        scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1)\n\n        scope.fire('interactable:unset', { interactable: this })\n      }\n    }\n  }\n\n  addListeners (map: ListenerMap, id?: string) {\n    this.listenerMaps.push({ id, map })\n  }\n\n  fire<T extends ListenerName> (name: T, arg: SignalArgs[T]): void | false {\n    for (const {\n      map: { [name]: listener },\n    } of this.listenerMaps) {\n      if (!!listener && listener(arg as any, this, name as never) === false) {\n        return false\n      }\n    }\n  }\n\n  onWindowUnload = (event: BeforeUnloadEvent) => this.removeDocument(event.target as Document)\n\n  init (window: Window | typeof globalThis) {\n    return this.isInitialized ? this : initScope(this, window)\n  }\n\n  pluginIsInstalled (plugin: Plugin) {\n    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1\n  }\n\n  usePlugin (plugin: Plugin, options?: { [key: string]: any }) {\n    if (!this.isInitialized) {\n      return this\n    }\n\n    if (this.pluginIsInstalled(plugin)) {\n      return this\n    }\n\n    if (plugin.id) {\n      this._plugins.map[plugin.id] = plugin\n    }\n    this._plugins.list.push(plugin)\n\n    if (plugin.install) {\n      plugin.install(this, options)\n    }\n\n    if (plugin.listeners && plugin.before) {\n      let index = 0\n      const len = this.listenerMaps.length\n      const before = plugin.before.reduce((acc, id) => {\n        acc[id] = true\n        acc[pluginIdRoot(id)] = true\n        return acc\n      }, {})\n\n      for (; index < len; index++) {\n        const otherId = this.listenerMaps[index].id\n\n        if (before[otherId] || before[pluginIdRoot(otherId)]) {\n          break\n        }\n      }\n\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\n    } else if (plugin.listeners) {\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\n    }\n\n    return this\n  }\n\n  addDocument (doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) {\n      return false\n    }\n\n    const window = win.getWindow(doc)\n\n    options = options ? extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    this.events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      this.events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.fire('scope:add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument (doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    this.events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    this.events.documents.splice(index, 1)\n\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\n  }\n\n  getDocIndex (doc: Document) {\n    for (let i = 0; i < this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions (doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n\n  now () {\n    return (((this.window as any).Date as typeof Date) || Date).now()\n  }\n}\n\nexport function initScope (scope: Scope, window: Window | typeof globalThis) {\n  scope.isInitialized = true\n\n  if (is.window(window)) {\n    win.init(window)\n  }\n\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n\n  // @ts-expect-error\n  scope.window = window\n  scope.document = window.document\n\n  scope.usePlugin(interactions)\n  scope.usePlugin(events)\n\n  return scope\n}\n\nfunction pluginIdRoot (id: string) {\n  return id && id.replace(/\\/.*$/, '')\n}\n", "import { Scope } from '@interactjs/core/scope'\n\nconst scope = new Scope()\n\nconst interact = scope.interactStatic\n\nexport default interact\n\nconst _global = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : this\nscope.init(_global)\n"],
  "mappings": "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",
  "names": []
}

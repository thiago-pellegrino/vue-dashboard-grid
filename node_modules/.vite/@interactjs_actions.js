import {
  BaseEvent,
  extend,
  findIndex,
  getOriginXY_default,
  getPageXY,
  indexOfDeepestElement,
  interact_default,
  is_default,
  matchesSelector,
  matchesUpTo,
  normalize,
  touchAngle,
  touchBBox,
  touchDistance
} from "./chunk-CABJS42X.js";
import "./chunk-Z47AEMLX.js";

// node_modules/@interactjs/actions/drag/plugin.js
function install(scope) {
  const {
    actions,
    Interactable,
    defaults
  } = scope;
  Interactable.prototype.draggable = drag.draggable;
  actions.map.drag = drag;
  actions.methodDict.drag = "draggable";
  defaults.actions.drag = drag.defaults;
}
function beforeMove({
  interaction
}) {
  if (interaction.prepared.name !== "drag")
    return;
  const axis = interaction.prepared.axis;
  if (axis === "x") {
    interaction.coords.cur.page.y = interaction.coords.start.page.y;
    interaction.coords.cur.client.y = interaction.coords.start.client.y;
    interaction.coords.velocity.client.y = 0;
    interaction.coords.velocity.page.y = 0;
  } else if (axis === "y") {
    interaction.coords.cur.page.x = interaction.coords.start.page.x;
    interaction.coords.cur.client.x = interaction.coords.start.client.x;
    interaction.coords.velocity.client.x = 0;
    interaction.coords.velocity.page.x = 0;
  }
}
function move({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== "drag")
    return;
  const axis = interaction.prepared.axis;
  if (axis === "x" || axis === "y") {
    const opposite = axis === "x" ? "y" : "x";
    iEvent.page[opposite] = interaction.coords.start.page[opposite];
    iEvent.client[opposite] = interaction.coords.start.client[opposite];
    iEvent.delta[opposite] = 0;
  }
}
var draggable = function draggable2(options) {
  if (is_default.object(options)) {
    this.options.drag.enabled = options.enabled !== false;
    this.setPerAction("drag", options);
    this.setOnEvents("drag", options);
    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {
      this.options.drag.lockAxis = options.lockAxis;
    }
    if (/^(xy|x|y)$/.test(options.startAxis)) {
      this.options.drag.startAxis = options.startAxis;
    }
    return this;
  }
  if (is_default.bool(options)) {
    this.options.drag.enabled = options;
    return this;
  }
  return this.options.drag;
};
var drag = {
  id: "actions/drag",
  install,
  listeners: {
    "interactions:before-action-move": beforeMove,
    "interactions:action-resume": beforeMove,
    "interactions:action-move": move,
    "auto-start:check": (arg) => {
      const {
        interaction,
        interactable,
        buttons
      } = arg;
      const dragOptions = interactable.options.drag;
      if (!(dragOptions && dragOptions.enabled) || interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & interactable.options.drag.mouseButtons) === 0) {
        return void 0;
      }
      arg.action = {
        name: "drag",
        axis: dragOptions.lockAxis === "start" ? dragOptions.startAxis : dragOptions.lockAxis
      };
      return false;
    }
  },
  draggable,
  beforeMove,
  move,
  defaults: {
    startAxis: "xy",
    lockAxis: "xy"
  },
  getCursor() {
    return "move";
  }
};
var plugin_default = drag;

// node_modules/@interactjs/actions/drop/DropEvent.js
var DropEvent = class extends BaseEvent {
  constructor(dropState, dragEvent, type) {
    super(dragEvent._interaction);
    this.target = void 0;
    this.dropzone = void 0;
    this.dragEvent = void 0;
    this.relatedTarget = void 0;
    this.draggable = void 0;
    this.timeStamp = void 0;
    this.propagationStopped = false;
    this.immediatePropagationStopped = false;
    const {
      element,
      dropzone
    } = type === "dragleave" ? dropState.prev : dropState.cur;
    this.type = type;
    this.target = element;
    this.currentTarget = element;
    this.dropzone = dropzone;
    this.dragEvent = dragEvent;
    this.relatedTarget = dragEvent.target;
    this.draggable = dragEvent.interactable;
    this.timeStamp = dragEvent.timeStamp;
  }
  reject() {
    const {
      dropState
    } = this._interaction;
    if (this.type !== "dropactivate" && (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)) {
      return;
    }
    dropState.prev.dropzone = this.dropzone;
    dropState.prev.element = this.target;
    dropState.rejected = true;
    dropState.events.enter = null;
    this.stopImmediatePropagation();
    if (this.type === "dropactivate") {
      const activeDrops = dropState.activeDrops;
      const index = findIndex(activeDrops, ({
        dropzone,
        element
      }) => dropzone === this.dropzone && element === this.target);
      dropState.activeDrops.splice(index, 1);
      const deactivateEvent = new DropEvent(dropState, this.dragEvent, "dropdeactivate");
      deactivateEvent.dropzone = this.dropzone;
      deactivateEvent.target = this.target;
      this.dropzone.fire(deactivateEvent);
    } else {
      this.dropzone.fire(new DropEvent(dropState, this.dragEvent, "dragleave"));
    }
  }
  preventDefault() {
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
  stopImmediatePropagation() {
    this.immediatePropagationStopped = this.propagationStopped = true;
  }
};

// node_modules/@interactjs/actions/drop/plugin.js
function install2(scope) {
  const {
    actions,
    interactStatic: interact,
    Interactable,
    defaults
  } = scope;
  scope.usePlugin(plugin_default);
  Interactable.prototype.dropzone = function(options) {
    return dropzoneMethod(this, options);
  };
  Interactable.prototype.dropCheck = function(dragEvent, event, draggable3, draggableElement, dropElement, rect) {
    return dropCheckMethod(this, dragEvent, event, draggable3, draggableElement, dropElement, rect);
  };
  interact.dynamicDrop = function(newValue) {
    if (is_default.bool(newValue)) {
      scope.dynamicDrop = newValue;
      return interact;
    }
    return scope.dynamicDrop;
  };
  extend(actions.phaselessTypes, {
    dragenter: true,
    dragleave: true,
    dropactivate: true,
    dropdeactivate: true,
    dropmove: true,
    drop: true
  });
  actions.methodDict.drop = "dropzone";
  scope.dynamicDrop = false;
  defaults.actions.drop = drop.defaults;
}
function collectDrops({
  interactables
}, draggableElement) {
  const drops = [];
  for (const dropzone of interactables.list) {
    if (!dropzone.options.drop.enabled) {
      continue;
    }
    const accept = dropzone.options.drop.accept;
    if (is_default.element(accept) && accept !== draggableElement || is_default.string(accept) && !matchesSelector(draggableElement, accept) || is_default.func(accept) && !accept({
      dropzone,
      draggableElement
    })) {
      continue;
    }
    const dropElements = is_default.string(dropzone.target) ? dropzone._context.querySelectorAll(dropzone.target) : is_default.array(dropzone.target) ? dropzone.target : [dropzone.target];
    for (const dropzoneElement of dropElements) {
      if (dropzoneElement !== draggableElement) {
        drops.push({
          dropzone,
          element: dropzoneElement,
          rect: dropzone.getRect(dropzoneElement)
        });
      }
    }
  }
  return drops;
}
function fireActivationEvents(activeDrops, event) {
  for (const {
    dropzone,
    element
  } of activeDrops.slice()) {
    event.dropzone = dropzone;
    event.target = element;
    dropzone.fire(event);
    event.propagationStopped = event.immediatePropagationStopped = false;
  }
}
function getActiveDrops(scope, dragElement) {
  const activeDrops = collectDrops(scope, dragElement);
  for (const activeDrop of activeDrops) {
    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element);
  }
  return activeDrops;
}
function getDrop({
  dropState,
  interactable: draggable3,
  element: dragElement
}, dragEvent, pointerEvent) {
  const validDrops = [];
  for (const {
    dropzone,
    element: dropzoneElement,
    rect
  } of dropState.activeDrops) {
    validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable3, dragElement, dropzoneElement, rect) ? dropzoneElement : null);
  }
  const dropIndex = indexOfDeepestElement(validDrops);
  return dropState.activeDrops[dropIndex] || null;
}
function getDropEvents(interaction, _pointerEvent, dragEvent) {
  const {
    dropState
  } = interaction;
  const dropEvents = {
    enter: null,
    leave: null,
    activate: null,
    deactivate: null,
    move: null,
    drop: null
  };
  if (dragEvent.type === "dragstart") {
    dropEvents.activate = new DropEvent(dropState, dragEvent, "dropactivate");
    dropEvents.activate.target = null;
    dropEvents.activate.dropzone = null;
  }
  if (dragEvent.type === "dragend") {
    dropEvents.deactivate = new DropEvent(dropState, dragEvent, "dropdeactivate");
    dropEvents.deactivate.target = null;
    dropEvents.deactivate.dropzone = null;
  }
  if (dropState.rejected) {
    return dropEvents;
  }
  if (dropState.cur.element !== dropState.prev.element) {
    if (dropState.prev.dropzone) {
      dropEvents.leave = new DropEvent(dropState, dragEvent, "dragleave");
      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element;
      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone;
    }
    if (dropState.cur.dropzone) {
      dropEvents.enter = new DropEvent(dropState, dragEvent, "dragenter");
      dragEvent.dragEnter = dropState.cur.element;
      dragEvent.dropzone = dropState.cur.dropzone;
    }
  }
  if (dragEvent.type === "dragend" && dropState.cur.dropzone) {
    dropEvents.drop = new DropEvent(dropState, dragEvent, "drop");
    dragEvent.dropzone = dropState.cur.dropzone;
    dragEvent.relatedTarget = dropState.cur.element;
  }
  if (dragEvent.type === "dragmove" && dropState.cur.dropzone) {
    dropEvents.move = new DropEvent(dropState, dragEvent, "dropmove");
    dropEvents.move.dragmove = dragEvent;
    dragEvent.dropzone = dropState.cur.dropzone;
  }
  return dropEvents;
}
function fireDropEvents(interaction, events) {
  const {
    dropState
  } = interaction;
  const {
    activeDrops,
    cur,
    prev
  } = dropState;
  if (events.leave) {
    prev.dropzone.fire(events.leave);
  }
  if (events.enter) {
    cur.dropzone.fire(events.enter);
  }
  if (events.move) {
    cur.dropzone.fire(events.move);
  }
  if (events.drop) {
    cur.dropzone.fire(events.drop);
  }
  if (events.deactivate) {
    fireActivationEvents(activeDrops, events.deactivate);
  }
  dropState.prev.dropzone = cur.dropzone;
  dropState.prev.element = cur.element;
}
function onEventCreated({
  interaction,
  iEvent,
  event
}, scope) {
  if (iEvent.type !== "dragmove" && iEvent.type !== "dragend") {
    return;
  }
  const {
    dropState
  } = interaction;
  if (scope.dynamicDrop) {
    dropState.activeDrops = getActiveDrops(scope, interaction.element);
  }
  const dragEvent = iEvent;
  const dropResult = getDrop(interaction, dragEvent, event);
  dropState.rejected = dropState.rejected && !!dropResult && dropResult.dropzone === dropState.cur.dropzone && dropResult.element === dropState.cur.element;
  dropState.cur.dropzone = dropResult && dropResult.dropzone;
  dropState.cur.element = dropResult && dropResult.element;
  dropState.events = getDropEvents(interaction, event, dragEvent);
}
function dropzoneMethod(interactable, options) {
  if (is_default.object(options)) {
    interactable.options.drop.enabled = options.enabled !== false;
    if (options.listeners) {
      const normalized = normalize(options.listeners);
      const corrected = Object.keys(normalized).reduce((acc, type) => {
        const correctedType = /^(enter|leave)/.test(type) ? `drag${type}` : /^(activate|deactivate|move)/.test(type) ? `drop${type}` : type;
        acc[correctedType] = normalized[type];
        return acc;
      }, {});
      interactable.off(interactable.options.drop.listeners);
      interactable.on(corrected);
      interactable.options.drop.listeners = corrected;
    }
    if (is_default.func(options.ondrop)) {
      interactable.on("drop", options.ondrop);
    }
    if (is_default.func(options.ondropactivate)) {
      interactable.on("dropactivate", options.ondropactivate);
    }
    if (is_default.func(options.ondropdeactivate)) {
      interactable.on("dropdeactivate", options.ondropdeactivate);
    }
    if (is_default.func(options.ondragenter)) {
      interactable.on("dragenter", options.ondragenter);
    }
    if (is_default.func(options.ondragleave)) {
      interactable.on("dragleave", options.ondragleave);
    }
    if (is_default.func(options.ondropmove)) {
      interactable.on("dropmove", options.ondropmove);
    }
    if (/^(pointer|center)$/.test(options.overlap)) {
      interactable.options.drop.overlap = options.overlap;
    } else if (is_default.number(options.overlap)) {
      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);
    }
    if ("accept" in options) {
      interactable.options.drop.accept = options.accept;
    }
    if ("checker" in options) {
      interactable.options.drop.checker = options.checker;
    }
    return interactable;
  }
  if (is_default.bool(options)) {
    interactable.options.drop.enabled = options;
    return interactable;
  }
  return interactable.options.drop;
}
function dropCheckMethod(interactable, dragEvent, event, draggable3, draggableElement, dropElement, rect) {
  let dropped = false;
  if (!(rect = rect || interactable.getRect(dropElement))) {
    return interactable.options.drop.checker ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable3, draggableElement) : false;
  }
  const dropOverlap = interactable.options.drop.overlap;
  if (dropOverlap === "pointer") {
    const origin = getOriginXY_default(draggable3, draggableElement, "drag");
    const page = getPageXY(dragEvent);
    page.x += origin.x;
    page.y += origin.y;
    const horizontal = page.x > rect.left && page.x < rect.right;
    const vertical = page.y > rect.top && page.y < rect.bottom;
    dropped = horizontal && vertical;
  }
  const dragRect = draggable3.getRect(draggableElement);
  if (dragRect && dropOverlap === "center") {
    const cx = dragRect.left + dragRect.width / 2;
    const cy = dragRect.top + dragRect.height / 2;
    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;
  }
  if (dragRect && is_default.number(dropOverlap)) {
    const overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));
    const overlapRatio = overlapArea / (dragRect.width * dragRect.height);
    dropped = overlapRatio >= dropOverlap;
  }
  if (interactable.options.drop.checker) {
    dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable3, draggableElement);
  }
  return dropped;
}
var drop = {
  id: "actions/drop",
  install: install2,
  listeners: {
    "interactions:before-action-start": ({
      interaction
    }) => {
      if (interaction.prepared.name !== "drag") {
        return;
      }
      interaction.dropState = {
        cur: {
          dropzone: null,
          element: null
        },
        prev: {
          dropzone: null,
          element: null
        },
        rejected: null,
        events: null,
        activeDrops: []
      };
    },
    "interactions:after-action-start": ({
      interaction,
      event,
      iEvent: dragEvent
    }, scope) => {
      if (interaction.prepared.name !== "drag") {
        return;
      }
      const {
        dropState
      } = interaction;
      dropState.activeDrops = null;
      dropState.events = null;
      dropState.activeDrops = getActiveDrops(scope, interaction.element);
      dropState.events = getDropEvents(interaction, event, dragEvent);
      if (dropState.events.activate) {
        fireActivationEvents(dropState.activeDrops, dropState.events.activate);
        scope.fire("actions/drop:start", {
          interaction,
          dragEvent
        });
      }
    },
    "interactions:action-move": onEventCreated,
    "interactions:after-action-move": ({
      interaction,
      iEvent: dragEvent
    }, scope) => {
      if (interaction.prepared.name !== "drag") {
        return;
      }
      fireDropEvents(interaction, interaction.dropState.events);
      scope.fire("actions/drop:move", {
        interaction,
        dragEvent
      });
      interaction.dropState.events = {};
    },
    "interactions:action-end": (arg, scope) => {
      if (arg.interaction.prepared.name !== "drag") {
        return;
      }
      const {
        interaction,
        iEvent: dragEvent
      } = arg;
      onEventCreated(arg, scope);
      fireDropEvents(interaction, interaction.dropState.events);
      scope.fire("actions/drop:end", {
        interaction,
        dragEvent
      });
    },
    "interactions:stop": ({
      interaction
    }) => {
      if (interaction.prepared.name !== "drag") {
        return;
      }
      const {
        dropState
      } = interaction;
      if (dropState) {
        dropState.activeDrops = null;
        dropState.events = null;
        dropState.cur.dropzone = null;
        dropState.cur.element = null;
        dropState.prev.dropzone = null;
        dropState.prev.element = null;
        dropState.rejected = false;
      }
    }
  },
  getActiveDrops,
  getDrop,
  getDropEvents,
  fireDropEvents,
  defaults: {
    enabled: false,
    accept: null,
    overlap: "pointer"
  }
};
var plugin_default2 = drop;

// node_modules/@interactjs/actions/gesture/plugin.js
function install3(scope) {
  const {
    actions,
    Interactable,
    defaults
  } = scope;
  Interactable.prototype.gesturable = function(options) {
    if (is_default.object(options)) {
      this.options.gesture.enabled = options.enabled !== false;
      this.setPerAction("gesture", options);
      this.setOnEvents("gesture", options);
      return this;
    }
    if (is_default.bool(options)) {
      this.options.gesture.enabled = options;
      return this;
    }
    return this.options.gesture;
  };
  actions.map.gesture = gesture;
  actions.methodDict.gesture = "gesturable";
  defaults.actions.gesture = gesture.defaults;
}
function updateGestureProps({
  interaction,
  iEvent,
  phase
}) {
  if (interaction.prepared.name !== "gesture")
    return;
  const pointers = interaction.pointers.map((p) => p.pointer);
  const starting = phase === "start";
  const ending = phase === "end";
  const deltaSource = interaction.interactable.options.deltaSource;
  iEvent.touches = [pointers[0], pointers[1]];
  if (starting) {
    iEvent.distance = touchDistance(pointers, deltaSource);
    iEvent.box = touchBBox(pointers);
    iEvent.scale = 1;
    iEvent.ds = 0;
    iEvent.angle = touchAngle(pointers, deltaSource);
    iEvent.da = 0;
    interaction.gesture.startDistance = iEvent.distance;
    interaction.gesture.startAngle = iEvent.angle;
  } else if (ending) {
    const prevEvent = interaction.prevEvent;
    iEvent.distance = prevEvent.distance;
    iEvent.box = prevEvent.box;
    iEvent.scale = prevEvent.scale;
    iEvent.ds = 0;
    iEvent.angle = prevEvent.angle;
    iEvent.da = 0;
  } else {
    iEvent.distance = touchDistance(pointers, deltaSource);
    iEvent.box = touchBBox(pointers);
    iEvent.scale = iEvent.distance / interaction.gesture.startDistance;
    iEvent.angle = touchAngle(pointers, deltaSource);
    iEvent.ds = iEvent.scale - interaction.gesture.scale;
    iEvent.da = iEvent.angle - interaction.gesture.angle;
  }
  interaction.gesture.distance = iEvent.distance;
  interaction.gesture.angle = iEvent.angle;
  if (is_default.number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) {
    interaction.gesture.scale = iEvent.scale;
  }
}
var gesture = {
  id: "actions/gesture",
  before: ["actions/drag", "actions/resize"],
  install: install3,
  listeners: {
    "interactions:action-start": updateGestureProps,
    "interactions:action-move": updateGestureProps,
    "interactions:action-end": updateGestureProps,
    "interactions:new": ({
      interaction
    }) => {
      interaction.gesture = {
        angle: 0,
        distance: 0,
        scale: 1,
        startAngle: 0,
        startDistance: 0
      };
    },
    "auto-start:check": (arg) => {
      if (arg.interaction.pointers.length < 2) {
        return void 0;
      }
      const gestureOptions = arg.interactable.options.gesture;
      if (!(gestureOptions && gestureOptions.enabled)) {
        return void 0;
      }
      arg.action = {
        name: "gesture"
      };
      return false;
    }
  },
  defaults: {},
  getCursor() {
    return "";
  }
};
var plugin_default3 = gesture;

// node_modules/@interactjs/actions/resize/plugin.js
function install4(scope) {
  const {
    actions,
    browser,
    Interactable,
    defaults
  } = scope;
  resize.cursors = initCursors(browser);
  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;
  Interactable.prototype.resizable = function(options) {
    return resizable(this, options, scope);
  };
  actions.map.resize = resize;
  actions.methodDict.resize = "resizable";
  defaults.actions.resize = resize.defaults;
}
function resizeChecker(arg) {
  const {
    interaction,
    interactable,
    element,
    rect,
    buttons
  } = arg;
  if (!rect) {
    return void 0;
  }
  const page = extend({}, interaction.coords.cur.page);
  const resizeOptions = interactable.options.resize;
  if (!(resizeOptions && resizeOptions.enabled) || interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & resizeOptions.mouseButtons) === 0) {
    return void 0;
  }
  if (is_default.object(resizeOptions.edges)) {
    const resizeEdges = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    for (const edge in resizeEdges) {
      resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._latestPointer.eventTarget, element, rect, resizeOptions.margin || resize.defaultMargin);
    }
    resizeEdges.left = resizeEdges.left && !resizeEdges.right;
    resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;
    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {
      arg.action = {
        name: "resize",
        edges: resizeEdges
      };
    }
  } else {
    const right = resizeOptions.axis !== "y" && page.x > rect.right - resize.defaultMargin;
    const bottom = resizeOptions.axis !== "x" && page.y > rect.bottom - resize.defaultMargin;
    if (right || bottom) {
      arg.action = {
        name: "resize",
        axes: (right ? "x" : "") + (bottom ? "y" : "")
      };
    }
  }
  return arg.action ? false : void 0;
}
function resizable(interactable, options, scope) {
  if (is_default.object(options)) {
    interactable.options.resize.enabled = options.enabled !== false;
    interactable.setPerAction("resize", options);
    interactable.setOnEvents("resize", options);
    if (is_default.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {
      interactable.options.resize.axis = options.axis;
    } else if (options.axis === null) {
      interactable.options.resize.axis = scope.defaults.actions.resize.axis;
    }
    if (is_default.bool(options.preserveAspectRatio)) {
      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio;
    } else if (is_default.bool(options.square)) {
      interactable.options.resize.square = options.square;
    }
    return interactable;
  }
  if (is_default.bool(options)) {
    interactable.options.resize.enabled = options;
    return interactable;
  }
  return interactable.options.resize;
}
function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {
  if (!value) {
    return false;
  }
  if (value === true) {
    const width = is_default.number(rect.width) ? rect.width : rect.right - rect.left;
    const height = is_default.number(rect.height) ? rect.height : rect.bottom - rect.top;
    margin = Math.min(margin, Math.abs((name === "left" || name === "right" ? width : height) / 2));
    if (width < 0) {
      if (name === "left") {
        name = "right";
      } else if (name === "right") {
        name = "left";
      }
    }
    if (height < 0) {
      if (name === "top") {
        name = "bottom";
      } else if (name === "bottom") {
        name = "top";
      }
    }
    if (name === "left") {
      return page.x < (width >= 0 ? rect.left : rect.right) + margin;
    }
    if (name === "top") {
      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;
    }
    if (name === "right") {
      return page.x > (width >= 0 ? rect.right : rect.left) - margin;
    }
    if (name === "bottom") {
      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;
    }
  }
  if (!is_default.element(element)) {
    return false;
  }
  return is_default.element(value) ? value === element : matchesUpTo(element, value, interactableElement);
}
function initCursors(browser) {
  return browser.isIe9 ? {
    x: "e-resize",
    y: "s-resize",
    xy: "se-resize",
    top: "n-resize",
    left: "w-resize",
    bottom: "s-resize",
    right: "e-resize",
    topleft: "se-resize",
    bottomright: "se-resize",
    topright: "ne-resize",
    bottomleft: "ne-resize"
  } : {
    x: "ew-resize",
    y: "ns-resize",
    xy: "nwse-resize",
    top: "ns-resize",
    left: "ew-resize",
    bottom: "ns-resize",
    right: "ew-resize",
    topleft: "nwse-resize",
    bottomright: "nwse-resize",
    topright: "nesw-resize",
    bottomleft: "nesw-resize"
  };
}
function start({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== "resize" || !interaction.prepared.edges) {
    return;
  }
  const resizeEvent = iEvent;
  const rect = interaction.rect;
  interaction._rects = {
    start: extend({}, rect),
    corrected: extend({}, rect),
    previous: extend({}, rect),
    delta: {
      left: 0,
      right: 0,
      width: 0,
      top: 0,
      bottom: 0,
      height: 0
    }
  };
  resizeEvent.edges = interaction.prepared.edges;
  resizeEvent.rect = interaction._rects.corrected;
  resizeEvent.deltaRect = interaction._rects.delta;
}
function move2({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== "resize" || !interaction.prepared.edges)
    return;
  const resizeEvent = iEvent;
  const resizeOptions = interaction.interactable.options.resize;
  const invert = resizeOptions.invert;
  const invertible = invert === "reposition" || invert === "negate";
  const current = interaction.rect;
  const {
    start: startRect,
    corrected,
    delta: deltaRect,
    previous
  } = interaction._rects;
  extend(previous, corrected);
  if (invertible) {
    extend(corrected, current);
    if (invert === "reposition") {
      if (corrected.top > corrected.bottom) {
        const swap = corrected.top;
        corrected.top = corrected.bottom;
        corrected.bottom = swap;
      }
      if (corrected.left > corrected.right) {
        const swap = corrected.left;
        corrected.left = corrected.right;
        corrected.right = swap;
      }
    }
  } else {
    corrected.top = Math.min(current.top, startRect.bottom);
    corrected.bottom = Math.max(current.bottom, startRect.top);
    corrected.left = Math.min(current.left, startRect.right);
    corrected.right = Math.max(current.right, startRect.left);
  }
  corrected.width = corrected.right - corrected.left;
  corrected.height = corrected.bottom - corrected.top;
  for (const edge in corrected) {
    deltaRect[edge] = corrected[edge] - previous[edge];
  }
  resizeEvent.edges = interaction.prepared.edges;
  resizeEvent.rect = corrected;
  resizeEvent.deltaRect = deltaRect;
}
function end({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== "resize" || !interaction.prepared.edges)
    return;
  const resizeEvent = iEvent;
  resizeEvent.edges = interaction.prepared.edges;
  resizeEvent.rect = interaction._rects.corrected;
  resizeEvent.deltaRect = interaction._rects.delta;
}
function updateEventAxes({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== "resize" || !interaction.resizeAxes)
    return;
  const options = interaction.interactable.options;
  const resizeEvent = iEvent;
  if (options.resize.square) {
    if (interaction.resizeAxes === "y") {
      resizeEvent.delta.x = resizeEvent.delta.y;
    } else {
      resizeEvent.delta.y = resizeEvent.delta.x;
    }
    resizeEvent.axes = "xy";
  } else {
    resizeEvent.axes = interaction.resizeAxes;
    if (interaction.resizeAxes === "x") {
      resizeEvent.delta.y = 0;
    } else if (interaction.resizeAxes === "y") {
      resizeEvent.delta.x = 0;
    }
  }
}
var resize = {
  id: "actions/resize",
  before: ["actions/drag"],
  install: install4,
  listeners: {
    "interactions:new": ({
      interaction
    }) => {
      interaction.resizeAxes = "xy";
    },
    "interactions:action-start": (arg) => {
      start(arg);
      updateEventAxes(arg);
    },
    "interactions:action-move": (arg) => {
      move2(arg);
      updateEventAxes(arg);
    },
    "interactions:action-end": end,
    "auto-start:check": resizeChecker
  },
  defaults: {
    square: false,
    preserveAspectRatio: false,
    axis: "xy",
    margin: NaN,
    edges: null,
    invert: "none"
  },
  cursors: null,
  getCursor({
    edges,
    axis,
    name
  }) {
    const cursors = resize.cursors;
    let result = null;
    if (axis) {
      result = cursors[name + axis];
    } else if (edges) {
      let cursorKey = "";
      for (const edge of ["top", "bottom", "left", "right"]) {
        if (edges[edge]) {
          cursorKey += edge;
        }
      }
      result = cursors[cursorKey];
    }
    return result;
  },
  defaultMargin: null
};
var plugin_default4 = resize;

// node_modules/@interactjs/actions/plugin.js
var plugin_default5 = {
  id: "actions",
  install(scope) {
    scope.usePlugin(plugin_default3);
    scope.usePlugin(plugin_default4);
    scope.usePlugin(plugin_default);
    scope.usePlugin(plugin_default2);
  }
};

// node_modules/@interactjs/actions/index.js
interact_default.use(plugin_default5);
//# sourceMappingURL=@interactjs_actions.js.map

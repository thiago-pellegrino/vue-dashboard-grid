{
  "version": 3,
  "sources": ["../@interactjs/actions/drag/plugin.ts", "../@interactjs/actions/drop/DropEvent.ts", "../@interactjs/actions/drop/plugin.ts", "../@interactjs/actions/gesture/plugin.ts", "../@interactjs/actions/resize/plugin.ts", "../@interactjs/actions/plugin.ts", "../@interactjs/actions/index.ts"],
  "sourcesContent": ["import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, DraggableOptions, DropzoneOptions } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    draggable: DraggableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drag: DraggableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drag?: typeof drag\n  }\n}\n\nexport type DragEvent = InteractEvent<'drag'>\n\nexport type DraggableMethod = ActionMethod<DraggableOptions>\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  Interactable.prototype.draggable = drag.draggable\n\n  actions.map.drag = drag\n  actions.methodDict.drag = 'draggable'\n\n  defaults.actions.drag = drag.defaults\n}\n\nfunction beforeMove ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x') {\n    interaction.coords.cur.page.y = interaction.coords.start.page.y\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\n\n    interaction.coords.velocity.client.y = 0\n    interaction.coords.velocity.page.y = 0\n  } else if (axis === 'y') {\n    interaction.coords.cur.page.x = interaction.coords.start.page.x\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\n\n    interaction.coords.velocity.client.x = 0\n    interaction.coords.velocity.page.x = 0\n  }\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x' || axis === 'y') {\n    const opposite = axis === 'x' ? 'y' : 'x'\n\n    iEvent.page[opposite] = interaction.coords.start.page[opposite]\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\n    iEvent.delta[opposite] = 0\n  }\n}\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * })\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @alias Interactable.prototype.draggable\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nconst draggable: DraggableMethod = function draggable (\n  this: Interactable,\n  options?: DraggableOptions | boolean,\n): any {\n  if (is.object(options)) {\n    this.options.drag.enabled = options.enabled !== false\n    this.setPerAction('drag', options)\n    this.setOnEvents('drag', options)\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis\n    }\n\n    return this\n  }\n\n  if (is.bool(options)) {\n    this.options.drag.enabled = options\n\n    return this\n  }\n\n  return this.options.drag\n}\n\nconst drag: Plugin = {\n  id: 'actions/drag',\n  install,\n  listeners: {\n    'interactions:before-action-move': beforeMove,\n    'interactions:action-resume': beforeMove,\n\n    // dragmove\n    'interactions:action-move': move,\n    'auto-start:check': (arg) => {\n      const { interaction, interactable, buttons } = arg\n      const dragOptions = interactable.options.drag\n\n      if (\n        !(dragOptions && dragOptions.enabled) ||\n        // check mouseButton setting if the pointer is down\n        (interaction.pointerIsDown &&\n          /mouse|pointer/.test(interaction.pointerType) &&\n          (buttons & interactable.options.drag.mouseButtons) === 0)\n      ) {\n        return undefined\n      }\n\n      arg.action = {\n        name: 'drag',\n        axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis,\n      }\n\n      return false\n    },\n  },\n  draggable,\n  beforeMove,\n  move,\n  defaults: {\n    startAxis: 'xy',\n    lockAxis: 'xy',\n  } as DropzoneOptions,\n\n  getCursor () {\n    return 'move'\n  },\n}\n\nexport default drag\n", "import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\n\nimport type { DropState } from './plugin'\n\nexport class DropEvent extends BaseEvent<'drag'> {\n  target: Element\n  dropzone: Interactable\n  dragEvent: InteractEvent<'drag'>\n  relatedTarget: Element\n  draggable: Interactable\n  timeStamp: number\n  propagationStopped = false\n  immediatePropagationStopped = false\n\n  /**\n   * Class of events fired on dropzones during drags with acceptable targets.\n   */\n  constructor (dropState: DropState, dragEvent: InteractEvent<'drag'>, type: string) {\n    super(dragEvent._interaction)\n\n    const { element, dropzone } = type === 'dragleave' ? dropState.prev : dropState.cur\n\n    this.type = type\n    this.target = element\n    this.currentTarget = element\n    this.dropzone = dropzone\n    this.dragEvent = dragEvent\n    this.relatedTarget = dragEvent.target\n    this.draggable = dragEvent.interactable\n    this.timeStamp = dragEvent.timeStamp\n  }\n\n  /**\n   * If this is a `dropactivate` event, the dropzone element will be\n   * deactivated.\n   *\n   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the\n   * dropzone element and more.\n   */\n  reject () {\n    const { dropState } = this._interaction\n\n    if (\n      this.type !== 'dropactivate' &&\n      (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)\n    ) {\n      return\n    }\n\n    dropState.prev.dropzone = this.dropzone\n    dropState.prev.element = this.target\n\n    dropState.rejected = true\n    dropState.events.enter = null\n\n    this.stopImmediatePropagation()\n\n    if (this.type === 'dropactivate') {\n      const activeDrops = dropState.activeDrops\n      const index = arr.findIndex(\n        activeDrops,\n        ({ dropzone, element }) => dropzone === this.dropzone && element === this.target,\n      )\n\n      dropState.activeDrops.splice(index, 1)\n\n      const deactivateEvent = new DropEvent(dropState, this.dragEvent, 'dropdeactivate')\n\n      deactivateEvent.dropzone = this.dropzone\n      deactivateEvent.target = this.target\n\n      this.dropzone.fire(deactivateEvent)\n    } else {\n      this.dropzone.fire(new DropEvent(dropState, this.dragEvent, 'dragleave'))\n    }\n  }\n\n  preventDefault () {}\n\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n", "import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { DropzoneOptions, Element, PointerEventType, Rect } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { DragEvent } from '../drag/plugin'\nimport drag from '../drag/plugin'\n\nimport { DropEvent } from './DropEvent'\n\nexport interface DropzoneMethod {\n  (this: Interactable, options: DropzoneOptions | boolean): Interactable\n  (): DropzoneOptions\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: PointerEventType,\n      draggable: Interactable,\n      draggableElement: Element,\n      dropElemen: Element,\n      rect: any,\n    ) => boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropState?: DropState\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    prevDropzone?: Interactable\n    dropzone?: Interactable\n    dragEnter?: Element\n    dragLeave?: Element\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drop: DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drop?: typeof drop\n  }\n\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n\n  interface SignalArgs {\n    'actions/drop:start': DropSignalArg\n    'actions/drop:move': DropSignalArg\n    'actions/drop:end': DropSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/InteractStatic' {\n  interface InteractStatic {\n    dynamicDrop: (this: InteractStatic, newValue?: boolean) => boolean | this\n  }\n}\n\ninterface DropSignalArg {\n  interaction: Interaction<'drag'>\n  dragEvent: DragEvent\n}\n\nexport interface ActiveDrop {\n  dropzone: Interactable\n  element: Element\n  rect: Rect\n}\n\nexport interface DropState {\n  cur: {\n    // the dropzone a drag target might be dropped into\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  prev: {\n    // the dropzone that was recently dragged away from\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  // wheather the potential drop was rejected from a listener\n  rejected: boolean\n  // the drop events related to the current drag event\n  events: FiredDropEvents\n  activeDrops: ActiveDrop[]\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interactStatic: interact,\n    /** @lends Interactable */\n    Interactable,\n    defaults,\n  } = scope\n\n  scope.usePlugin(drag)\n\n  /**\n   *\n   * ```js\n   * interact('.drop').dropzone({\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\n   *   overlap: 'pointer' || 'center' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\n   *   - `'center'`, the draggable element's center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {object | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interactable, options?: DropzoneOptions | boolean) {\n    return dropzoneMethod(this, options)\n  } as Interactable['dropzone']\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped && event.target.hasAttribute('allow-drop')\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (\n    this: Interactable,\n    dragEvent,\n    event,\n    draggable,\n    draggableElement,\n    dropElement,\n    rect,\n  ) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (is.bool(newValue)) {\n      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  extend(actions.phaselessTypes, {\n    dragenter: true,\n    dragleave: true,\n    dropactivate: true,\n    dropdeactivate: true,\n    dropmove: true,\n    drop: true,\n  })\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }: Scope, draggableElement: Element) {\n  const drops: ActiveDrop[] = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) {\n      continue\n    }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if (\n      (is.element(accept) && accept !== draggableElement) ||\n      (is.string(accept) && !domUtils.matchesSelector(draggableElement, accept)) ||\n      (is.func(accept) && !accept({ dropzone, draggableElement }))\n    ) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = (is.string(dropzone.target)\n      ? dropzone._context.querySelectorAll(dropzone.target)\n      : is.array(dropzone.target)\n        ? dropzone.target\n        : [dropzone.target]) as Element[]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n          rect: dropzone.getRect(dropzoneElement),\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops: ActiveDrop[], event: DropEvent) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops.slice()) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Scope, dragElement: Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop (\n  { dropState, interactable: draggable, element: dragElement }: Partial<Interaction>,\n  dragEvent,\n  pointerEvent,\n) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    validDrops.push(\n      dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n        ? dropzoneElement\n        : null,\n    )\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = domUtils.indexOfDeepestElement(validDrops)\n\n  return dropState.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction: Interaction, _pointerEvent, dragEvent: DragEvent) {\n  const { dropState } = interaction\n  const dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\ntype FiredDropEvents = Partial<\nRecord<'leave' | 'enter' | 'move' | 'drop' | 'activate' | 'deactivate', DropEvent>\n>\n\nfunction fireDropEvents (interaction: Interaction, events: FiredDropEvents) {\n  const { dropState } = interaction\n  const { activeDrops, cur, prev } = dropState\n\n  if (events.leave) {\n    prev.dropzone.fire(events.leave)\n  }\n  if (events.enter) {\n    cur.dropzone.fire(events.enter)\n  }\n  if (events.move) {\n    cur.dropzone.fire(events.move)\n  }\n  if (events.drop) {\n    cur.dropzone.fire(events.drop)\n  }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }: DoPhaseArg<'drag', EventPhase>, scope: Scope) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n    return\n  }\n\n  const { dropState } = interaction\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected =\n    dropState.rejected &&\n    !!dropResult &&\n    dropResult.dropzone === dropState.cur.dropzone &&\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone = dropResult && dropResult.dropzone\n  dropState.cur.element = dropResult && dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod(interactable: Interactable): DropzoneOptions\nfunction dropzoneMethod(interactable: Interactable, options: DropzoneOptions | boolean): Interactable\nfunction dropzoneMethod (interactable: Interactable, options?: DropzoneOptions | boolean) {\n  if (is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (is.func(options.ondrop)) {\n      interactable.on('drop', options.ondrop)\n    }\n    if (is.func(options.ondropactivate)) {\n      interactable.on('dropactivate', options.ondropactivate)\n    }\n    if (is.func(options.ondropdeactivate)) {\n      interactable.on('dropdeactivate', options.ondropdeactivate)\n    }\n    if (is.func(options.ondragenter)) {\n      interactable.on('dragenter', options.ondragenter)\n    }\n    if (is.func(options.ondragleave)) {\n      interactable.on('dragleave', options.ondragleave)\n    }\n    if (is.func(options.ondropmove)) {\n      interactable.on('dropmove', options.ondropmove)\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    } else if (is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interactable,\n  dragEvent: InteractEvent,\n  event: PointerEventType,\n  draggable: Interactable,\n  draggableElement: Element,\n  dropElement: Element,\n  rect: any,\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return interactable.options.drop.checker\n      ? interactable.options.drop.checker(\n        dragEvent,\n        event,\n        dropped,\n        interactable,\n        dropElement,\n        draggable,\n        draggableElement,\n      )\n      : false\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = getOriginXY(draggable, draggableElement, 'drag')\n    const page = pointerUtils.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = page.x > rect.left && page.x < rect.right\n    const vertical = page.y > rect.top && page.y < rect.bottom\n\n    dropped = horizontal && vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width / 2\n    const cy = dragRect.top + dragRect.height / 2\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom\n  }\n\n  if (dragRect && is.number(dropOverlap)) {\n    const overlapArea =\n      Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n      Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(\n      dragEvent,\n      event,\n      dropped,\n      interactable,\n      dropElement,\n      draggable,\n      draggableElement,\n    )\n  }\n\n  return dropped\n}\n\nconst drop: Plugin = {\n  id: 'actions/drop',\n  install,\n  listeners: {\n    'interactions:before-action-start': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      interaction.dropState = {\n        cur: {\n          dropzone: null,\n          element: null,\n        },\n        prev: {\n          dropzone: null,\n          element: null,\n        },\n        rejected: null,\n        events: null,\n        activeDrops: [],\n      }\n    },\n\n    'interactions:after-action-start': (\n      { interaction, event, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      // reset active dropzones\n      dropState.activeDrops = null\n      dropState.events = null\n      dropState.activeDrops = getActiveDrops(scope, interaction.element)\n      dropState.events = getDropEvents(interaction, event, dragEvent)\n\n      if (dropState.events.activate) {\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n        scope.fire('actions/drop:start', { interaction, dragEvent })\n      }\n    },\n\n    'interactions:action-move': onEventCreated,\n\n    'interactions:after-action-move': (\n      { interaction, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      fireDropEvents(interaction, interaction.dropState.events)\n\n      scope.fire('actions/drop:move', { interaction, dragEvent })\n      interaction.dropState.events = {}\n    },\n\n    'interactions:action-end': (arg: DoPhaseArg<'drag', EventPhase>, scope) => {\n      if (arg.interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { interaction, iEvent: dragEvent } = arg\n\n      onEventCreated(arg, scope)\n      fireDropEvents(interaction, interaction.dropState.events)\n      scope.fire('actions/drop:end', { interaction, dragEvent })\n    },\n\n    'interactions:stop': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      if (dropState) {\n        dropState.activeDrops = null\n        dropState.events = null\n        dropState.cur.dropzone = null\n        dropState.cur.element = null\n        dropState.prev.dropzone = null\n        dropState.prev.element = null\n        dropState.rejected = false\n      }\n    },\n  },\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer',\n  } as DropzoneOptions,\n}\n\nexport default drop\n", "import type { InteractEvent, EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Options } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, GesturableOptions, Rect, PointerType } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport type GesturableMethod = ActionMethod<GesturableOptions>\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number // angle from first to second touch\n      distance: number\n      scale: number // gesture.distance / gesture.startDistance\n      startAngle: number // angle of line joining two touches\n      startDistance: number // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    gesture: GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GestureEvent extends InteractEvent<'gesture'> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Rect // enclosing box of all points\n  touches: PointerType[]\n}\n\nexport interface GestureSignalArg extends DoPhaseArg<'gesture', EventPhase> {\n  iEvent: GestureEvent\n  interaction: Interaction<'gesture'>\n}\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (\n    this: InstanceType<typeof Interactable>,\n    options: GesturableOptions | boolean,\n  ) {\n    if (is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Options\n  } as GesturableMethod\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') return\n\n  const pointers = interaction.pointers.map((p) => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = 1\n    iEvent.ds = 0\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n    iEvent.da = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  } else if (ending) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box = prevEvent.box\n    iEvent.scale = prevEvent.scale\n    iEvent.ds = 0\n    iEvent.angle = prevEvent.angle\n    iEvent.da = 0\n  } else {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (is.number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': (arg) => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {},\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n", "import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { ActionProps, Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type {\n  ActionMethod,\n  ResizableOptions,\n  FullRect,\n  OrBoolean,\n  Point,\n  Rect,\n} from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\n\nexport type ResizableMethod = ActionMethod<ResizableOptions>\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    resizable: ResizableMethod\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    resizeAxes: 'x' | 'y' | 'xy'\n    resizeStartAspectRatio: number\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    resize: ResizableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    resize?: typeof resize\n  }\n}\n\nexport interface ResizeEvent<P extends EventPhase = EventPhase> extends InteractEvent<'resize', P> {\n  deltaRect?: FullRect\n  edges?: ActionProps['edges']\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   *   // 'negate' will allow the rect to have negative width/height\n   *   // 'reposition' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: 'none' || 'negate' || 'reposition'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * })\n   *\n   * var isResizeable = interact(element).resizable()\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interactable, options: ResizableOptions | boolean) {\n    return resizable(this, options, scope)\n  } as ResizableMethod\n\n  actions.map.resize = resize\n  actions.methodDict.resize = 'resizable'\n\n  defaults.actions.resize = resize.defaults\n}\n\nfunction resizeChecker (arg) {\n  const { interaction, interactable, element, rect, buttons } = arg\n\n  if (!rect) {\n    return undefined\n  }\n\n  const page = extend({}, interaction.coords.cur.page)\n  const resizeOptions = interactable.options.resize\n\n  if (\n    !(resizeOptions && resizeOptions.enabled) ||\n    // check mouseButton setting if the pointer is down\n    (interaction.pointerIsDown &&\n      /mouse|pointer/.test(interaction.pointerType) &&\n      (buttons & resizeOptions.mouseButtons) === 0)\n  ) {\n    return undefined\n  }\n\n  // if using resize.edges\n  if (is.object(resizeOptions.edges)) {\n    const resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n\n    for (const edge in resizeEdges) {\n      resizeEdges[edge] = checkResizeEdge(\n        edge,\n        resizeOptions.edges[edge],\n        page,\n        interaction._latestPointer.eventTarget,\n        element,\n        rect,\n        resizeOptions.margin || resize.defaultMargin,\n      )\n    }\n\n    resizeEdges.left = resizeEdges.left && !resizeEdges.right\n    resizeEdges.top = resizeEdges.top && !resizeEdges.bottom\n\n    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n      arg.action = {\n        name: 'resize',\n        edges: resizeEdges,\n      }\n    }\n  } else {\n    const right = resizeOptions.axis !== 'y' && page.x > rect.right - resize.defaultMargin\n    const bottom = resizeOptions.axis !== 'x' && page.y > rect.bottom - resize.defaultMargin\n\n    if (right || bottom) {\n      arg.action = {\n        name: 'resize',\n        axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\n      }\n    }\n  }\n\n  return arg.action ? false : undefined\n}\n\nfunction resizable (interactable: Interactable, options: OrBoolean<ResizableOptions> | boolean, scope: Scope) {\n  if (is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction('resize', options)\n    interactable.setOnEvents('resize', options)\n\n    if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {\n      interactable.options.resize.axis = options.axis\n    } else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    } else if (is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (\n  name: string,\n  value: any,\n  page: Point,\n  element: Node,\n  interactableElement: Element,\n  rect: Rect,\n  margin: number,\n) {\n  // false, '', undefined, null\n  if (!value) {\n    return false\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width = is.number(rect.width) ? rect.width : rect.right - rect.left\n    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don't use margin greater than half the relevent dimension\n    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2))\n\n    if (width < 0) {\n      if (name === 'left') {\n        name = 'right'\n      } else if (name === 'right') {\n        name = 'left'\n      }\n    }\n    if (height < 0) {\n      if (name === 'top') {\n        name = 'bottom'\n      } else if (name === 'bottom') {\n        name = 'top'\n      }\n    }\n\n    if (name === 'left') {\n      return page.x < (width >= 0 ? rect.left : rect.right) + margin\n    }\n    if (name === 'top') {\n      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin\n    }\n\n    if (name === 'right') {\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin\n    }\n    if (name === 'bottom') {\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin\n    }\n  }\n\n  // the remaining checks require an element\n  if (!is.element(element)) {\n    return false\n  }\n\n  return is.element(value)\n    ? // the value is an element to use as a resize handle\n    value === element\n    : // otherwise check if element matches value as selector\n    dom.matchesUpTo(element, value, interactableElement)\n}\n\n/* eslint-disable multiline-ternary */\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nfunction initCursors (browser: typeof import('@interactjs/utils/browser').default) {\n  return browser.isIe9\n    ? {\n      x: 'e-resize',\n      y: 's-resize',\n      xy: 'se-resize',\n\n      top: 'n-resize',\n      left: 'w-resize',\n      bottom: 's-resize',\n      right: 'e-resize',\n      topleft: 'se-resize',\n      bottomright: 'se-resize',\n      topright: 'ne-resize',\n      bottomleft: 'ne-resize',\n    }\n    : {\n      x: 'ew-resize',\n      y: 'ns-resize',\n      xy: 'nwse-resize',\n\n      top: 'ns-resize',\n      left: 'ew-resize',\n      bottom: 'ns-resize',\n      right: 'ew-resize',\n      topleft: 'nwse-resize',\n      bottomright: 'nwse-resize',\n      topright: 'nesw-resize',\n      bottomleft: 'nesw-resize',\n    }\n}\n/* eslint-enable multiline-ternary */\n\nfunction start ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\n    return\n  }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const rect = interaction.rect\n\n  interaction._rects = {\n    start: extend({}, rect),\n    corrected: extend({}, rect),\n    previous: extend({}, rect),\n    delta: {\n      left: 0,\n      right: 0,\n      width: 0,\n      top: 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction move ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n  const resizeOptions = interaction.interactable.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === 'reposition' || invert === 'negate'\n\n  const current = interaction.rect\n  const { start: startRect, corrected, delta: deltaRect, previous } = interaction._rects\n\n  extend(previous, corrected)\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    extend(corrected, current)\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      if (corrected.top > corrected.bottom) {\n        const swap = corrected.top\n\n        corrected.top = corrected.bottom\n        corrected.bottom = swap\n      }\n      if (corrected.left > corrected.right) {\n        const swap = corrected.left\n\n        corrected.left = corrected.right\n        corrected.right = swap\n      }\n    }\n  } else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    corrected.top = Math.min(current.top, startRect.bottom)\n    corrected.bottom = Math.max(current.bottom, startRect.top)\n    corrected.left = Math.min(current.left, startRect.right)\n    corrected.right = Math.max(current.right, startRect.left)\n  }\n\n  corrected.width = corrected.right - corrected.left\n  corrected.height = corrected.bottom - corrected.top\n\n  for (const edge in corrected) {\n    deltaRect[edge] = corrected[edge] - previous[edge]\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = corrected\n  resizeEvent.deltaRect = deltaRect\n}\n\nfunction end ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction updateEventAxes ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent<any, any>\n  interaction: Interaction\n}) {\n  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) return\n\n  const options = interaction.interactable.options\n  const resizeEvent = iEvent as ResizeEvent\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = resizeEvent.delta.y\n    } else {\n      resizeEvent.delta.y = resizeEvent.delta.x\n    }\n    resizeEvent.axes = 'xy'\n  } else {\n    resizeEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === 'x') {\n      resizeEvent.delta.y = 0\n    } else if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = 0\n    }\n  }\n}\n\nconst resize: Plugin = {\n  id: 'actions/resize',\n  before: ['actions/drag'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.resizeAxes = 'xy'\n    },\n\n    'interactions:action-start': (arg) => {\n      start(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-move': (arg) => {\n      move(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-end': end,\n    'auto-start:check': resizeChecker,\n  },\n\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  } as ResizableOptions,\n\n  cursors: null as ReturnType<typeof initCursors>,\n\n  getCursor ({ edges, axis, name }: ActionProps) {\n    const cursors = resize.cursors\n    let result: string = null\n\n    if (axis) {\n      result = cursors[name + axis]\n    } else if (edges) {\n      let cursorKey = ''\n\n      for (const edge of ['top', 'bottom', 'left', 'right']) {\n        if (edges[edge]) {\n          cursorKey += edge\n        }\n      }\n\n      result = cursors[cursorKey]\n    }\n\n    return result\n  },\n\n  defaultMargin: null as number,\n}\n\nexport default resize\n", "import type { Scope } from '@interactjs/core/scope'\n\nimport drag from './drag/plugin'\nimport drop from './drop/plugin'\nimport gesture from './gesture/plugin'\nimport resize from './resize/plugin'\n\nexport default {\n  id: 'actions',\n  install (scope: Scope) {\n    scope.usePlugin(gesture)\n    scope.usePlugin(resize)\n    scope.usePlugin(drag)\n    scope.usePlugin(drop)\n  },\n}\n", "/* eslint-disable import/order, no-console, eol-last */\nimport interact from '@interactjs/interact/index'\nimport plugin from '@interactjs/actions/plugin'\ninteract.use(plugin)"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../@interactjs/auto-start/InteractableMethods.ts", "../@interactjs/auto-start/base.ts", "../@interactjs/auto-start/dragAxis.ts", "../@interactjs/auto-start/hold.ts", "../@interactjs/auto-start/plugin.ts", "../@interactjs/auto-start/index.ts"],
  "sourcesContent": ["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) => ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *       // force drag with handle target\n   *       action.name = drag\n   *     }\n   *     else {\n   *       // resize from the top and right edges\n   *       action.name  = 'resize'\n   *       action.edges = { top: true, right: true }\n   *     }\n   *\n   *     return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable): boolean\nfunction styleCursor(this: Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, ActionName, Plugin } from '@interactjs/core/scope'\nimport type { CursorChecker, PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\nimport InteractableMethods from './InteractableMethods'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install (scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName> (\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches (interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName> (\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName> (interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { SignalArgs, Scope, ActionName } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart ({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\n  if (interaction.prepared.name !== 'drag') return\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy'\n\n  interaction.prepared.axis =\n    targetOptions.lockAxis === 'start'\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    ;(interaction as Interaction<ActionName>).prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Element\n\n    const getDraggable = function (interactable: Interactable): Interactable | void {\n      if (interactable === interaction.interactable) return\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer,\n          interaction.downEvent,\n          interaction,\n          element,\n        )\n\n        if (\n          action &&\n          action.name === 'drag' &&\n          checkStartAxis(currentAxis, interactable) &&\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\n        ) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        ;(interaction as Interaction<ActionName>).prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Element\n    }\n  }\n}\n\nfunction checkStartAxis (startAxis: string, interactable: Interactable) {\n  if (!interactable) {\n    return false\n  }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\n\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoStartHoldTimer?: any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(basePlugin)\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n}\n\nfunction getHoldDuration (interaction: Interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name\n\n  if (!actionName) {\n    return null\n  }\n\n  const options = interaction.interactable.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nconst hold: Plugin = {\n  id: 'auto-start/hold',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoStartHoldTimer = null\n    },\n\n    'autoStart:prepared': ({ interaction }) => {\n      const hold = getHoldDuration(interaction)\n\n      if (hold > 0) {\n        interaction.autoStartHoldTimer = setTimeout(() => {\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\n        }, hold)\n      }\n    },\n\n    'interactions:move': ({ interaction, duplicate }) => {\n      if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {\n        clearTimeout(interaction.autoStartHoldTimer)\n        interaction.autoStartHoldTimer = null\n      }\n    },\n\n    // prevent regular down->move autoStart\n    'autoStart:before-start': ({ interaction }) => {\n      const holdDuration = getHoldDuration(interaction)\n\n      if (holdDuration > 0) {\n        interaction.prepared.name = null\n      }\n    },\n  },\n  getHoldDuration,\n}\nexport default hold\n", "import type { Scope } from '@interactjs/core/scope'\n\nimport autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n\nexport default {\n  id: 'auto-start',\n  install (scope: Scope) {\n    scope.usePlugin(autoStart)\n    scope.usePlugin(hold)\n    scope.usePlugin(dragAxis)\n  },\n}\n", "/* eslint-disable import/order, no-console, eol-last */\nimport interact from '@interactjs/interact/index'\nimport plugin from '@interactjs/auto-start/plugin'\ninteract.use(plugin)"],
  "mappings": "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",
  "names": []
}

{
	"version": 3,
	"sources": [
		"domUtils.ts"
	],
	"names": [
		"browser",
		"domObjects",
		"is",
		"win",
		"nodeContains",
		"parent",
		"child",
		"contains",
		"parentNode",
		"closest",
		"element",
		"selector",
		"matchesSelector",
		"node",
		"docFrag",
		"host",
		"window",
		"realWindow",
		"replace",
		"prefixedMatchesSelector",
		"getParent",
		"el",
		"indexOfDeepestElement",
		"elements",
		"deepestNodeParents",
		"deepestNodeIndex",
		"i",
		"length",
		"currentNode",
		"deepestNode",
		"currentNodeParent",
		"deepestNodeParent",
		"ownerDocument",
		"zIndexIsHigherThan",
		"getNodeParents",
		"ancestryStart",
		"HTMLElement",
		"SVGElement",
		"SVGSVGElement",
		"ownerSVGElement",
		"currentNodeParents",
		"commonIndex",
		"parents",
		"lastChild",
		"previousSibling",
		"limit",
		"parentParent",
		"unshift",
		"higherNode",
		"lowerNode",
		"higherIndex",
		"parseInt",
		"getWindow",
		"getComputedStyle",
		"zIndex",
		"lowerIndex",
		"matchesUpTo",
		"getActualElement",
		"correspondingUseElement",
		"getScrollXY",
		"relevantWindow",
		"x",
		"scrollX",
		"document",
		"documentElement",
		"scrollLeft",
		"y",
		"scrollY",
		"scrollTop",
		"getElementClientRect",
		"clientRect",
		"getBoundingClientRect",
		"getClientRects",
		"left",
		"right",
		"top",
		"bottom",
		"width",
		"height",
		"getElementRect",
		"isIOS7",
		"scroll",
		"getPath",
		"path",
		"push",
		"trySelector",
		"value",
		"string",
		"querySelector"
	],
	"mappings": "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",
	"sourcesContent": [
		"import type { Rect, Target, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains (parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents (node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo (element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Element) {\n  return (element as SVGElement).correspondingUseElement || element\n}\n\nexport function getScrollXY (relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect (element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n"
	]
}
{
	"version": 3,
	"sources": [
		"InteractableMethods.ts"
	],
	"names": [
		"is",
		"warnOnce",
		"styleCursor",
		"newValue",
		"bool",
		"this",
		"options",
		"actionChecker",
		"checker",
		"func",
		"id",
		"install",
		"scope",
		"Interactable",
		"prototype",
		"getAction",
		"pointer",
		"event",
		"interaction",
		"element",
		"action",
		"interactable",
		"rect",
		"getRect",
		"arg",
		"buttons",
		"0",
		"1",
		"3",
		"4",
		"button",
		"fire",
		"defaultActionChecker",
		"ignoreFrom",
		"_backCompatOption",
		"allowFrom"
	],
	"mappings": "OAIOA,MAAQ,yCACNC,MAAgB,wBAiLzB,SAASC,EAAiCC,GACxC,OAAIH,EAAGI,KAAKD,IACVE,KAAKC,QAAQJ,YAAcC,EAEpBE,MAGQ,OAAbF,UACKE,KAAKC,QAAQJ,YAEbG,MAGFA,KAAKC,QAAQJ,YAGtB,SAASK,EAAmCC,GAC1C,OAAIR,EAAGS,KAAKD,IACVH,KAAKC,QAAQC,cAAgBC,EAEtBH,MAGO,OAAZG,UACKH,KAAKC,QAAQC,cAEbF,MAGFA,KAAKC,QAAQC,4BAGP,CACbG,GAAI,iCACJC,QA3LgBC,GAChB,MAAMC,aAEJA,GACED,EAEJC,EAAaC,UAAUC,UAAY,SAEjCC,EACAC,EACAC,EACAC,GAEA,MAAMC,EA4GV,EACEC,EACAJ,EACAC,EACAC,EACAP,KAEA,MAAMU,EAAOD,EAAaE,QAAQJ,GAS5BK,EAAM,CACVJ,OAAQ,KACRC,aAAAA,EACAH,YAAAA,EACAC,QAAAA,EACAG,KAAAA,EACAG,QAbCR,EAAqBQ,SACtB,CACEC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,IACFZ,EAAqBa,SAY1B,OAFAlB,EAAMmB,KAAK,mBAAoBP,GAExBA,EAAIJ,QAvIMY,CAAqB3B,KAAMY,EAAOC,EAAaC,EAASP,GAEvE,OAAIP,KAAKC,QAAQC,cACRF,KAAKC,QAAQC,cAAcS,EAASC,EAAOG,EAAQf,KAAMc,EAASD,GAGpEE,GA2BTP,EAAaC,UAAUmB,WAAahC,GAAS,SAA8BE,GACzE,OAAOE,KAAK6B,kBAAkB,aAAc/B,KAC3C,qGA0BHU,EAAaC,UAAUqB,UAAYlC,GAAS,SAA8BE,GACxE,OAAOE,KAAK6B,kBAAkB,YAAa/B,KAC1C,mGAiCHU,EAAaC,UAAUP,cAAgBA,EASvCM,EAAaC,UAAUZ,YAAcA",
	"sourcesContent": [
		"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) => ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *       // force drag with handle target\n   *       action.name = drag\n   *     }\n   *     else {\n   *       // resize from the top and right edges\n   *       action.name  = 'resize'\n   *       action.edges = { top: true, right: true }\n   *     }\n   *\n   *     return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable): boolean\nfunction styleCursor(this: Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n"
	]
}
{
	"version": 3,
	"sources": [
		"plugin.ts"
	],
	"names": [
		"is",
		"pointerUtils",
		"install",
		"scope",
		"actions",
		"Interactable",
		"defaults",
		"prototype",
		"gesturable",
		"options",
		"object",
		"gesture",
		"enabled",
		"setPerAction",
		"setOnEvents",
		"bool",
		"map",
		"methodDict",
		"updateGestureProps",
		"interaction",
		"iEvent",
		"phase",
		"prepared",
		"name",
		"pointers",
		"p",
		"pointer",
		"starting",
		"ending",
		"deltaSource",
		"interactable",
		"touches",
		"distance",
		"touchDistance",
		"box",
		"touchBBox",
		"scale",
		"ds",
		"angle",
		"touchAngle",
		"da",
		"startDistance",
		"startAngle",
		"prevEvent",
		"number",
		"Infinity",
		"isNaN",
		"id",
		"before",
		"listeners",
		"arg",
		"length",
		"undefined",
		"gestureOptions",
		"action",
		"getCursor"
	],
	"mappings": "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",
	"sourcesContent": [
		"import type { InteractEvent, EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Options } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, GesturableOptions, Rect, PointerType } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport type GesturableMethod = ActionMethod<GesturableOptions>\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number // angle from first to second touch\n      distance: number\n      scale: number // gesture.distance / gesture.startDistance\n      startAngle: number // angle of line joining two touches\n      startDistance: number // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    gesture: GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GestureEvent extends InteractEvent<'gesture'> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Rect // enclosing box of all points\n  touches: PointerType[]\n}\n\nexport interface GestureSignalArg extends DoPhaseArg<'gesture', EventPhase> {\n  iEvent: GestureEvent\n  interaction: Interaction<'gesture'>\n}\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (\n    this: InstanceType<typeof Interactable>,\n    options: GesturableOptions | boolean,\n  ) {\n    if (is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Options\n  } as GesturableMethod\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') return\n\n  const pointers = interaction.pointers.map((p) => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = 1\n    iEvent.ds = 0\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n    iEvent.da = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  } else if (ending) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box = prevEvent.box\n    iEvent.scale = prevEvent.scale\n    iEvent.ds = 0\n    iEvent.angle = prevEvent.angle\n    iEvent.da = 0\n  } else {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (is.number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': (arg) => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {},\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n"
	]
}